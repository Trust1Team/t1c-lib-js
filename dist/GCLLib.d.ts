// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../es6-promise

import { Promise } from 'es6-promise';

class GCLClient {
    GCLInstalled: boolean;
    constructor(cfg: GCLConfig, automatic: boolean);
    static initialize(cfg: GCLConfig, callback?: (error: CoreExceptions.RestException, client: GCLClient) => void): Promise<GCLClient>;
    admin: () => AdminService;
    core: () => CoreService;
    config: () => GCLConfig;
    agent: () => AbstractAgent;
    ds: () => DSClient;
    ocv: () => AbstractOCVClient;
    pf: () => PluginFactory;
    beid: (reader_id?: string) => AbstractEidBE;
    dnie: (reader_id?: string) => AbstractDNIe;
    luxeid: (reader_id?: string, pin?: string) => AbstractEidLUX;
    luxtrust: (reader_id?: string, pin?: string) => AbstractLuxTrust;
    emv: (reader_id?: string) => AbstractEMV;
    mobib: (reader_id?: string) => AbstractMobib;
    ocra: (reader_id?: string) => AbstractOcra;
    aventra: (reader_id?: string) => AbstractAventra;
    oberthur: (reader_id?: string) => AbstractOberthur;
    piv: (reader_id?: string) => AbstractPiv;
    pteid: (reader_id?: string) => AbstractEidPT;
    pkcs11: () => AbstractPkcs11;
    readerapi: (reader_id: string) => AbstractRemoteLoading;
    belfius: (reader_id: string) => AbstractBelfius;
    containerFor(readerId: string, callback?: (error: RestException, data: DataResponse) => void): any;
    download(callback?: (error: RestException, data: DownloadLinkResponse) => void): any;
    dumpData(readerId: string, data: OptionalPin, callback?: (error: RestException, data: DataResponse) => void): any;
    readersCanAuthenticate(callback?: (error: RestException, data: CardReadersResponse) => void): any;
    authenticate(readerId: string, data: AuthenticateOrSignData, callback?: (error: RestException, data: DataResponse) => void): any;
    readersCanSign(callback?: (error: RestException, data: CardReadersResponse) => void): any;
    sign(readerId: string, data: AuthenticateOrSignData, callback?: (error: RestException, data: DataResponse) => void): any;
    readersCanVerifyPin(callback?: (error: RestException, data: CardReadersResponse) => void): any;
    verifyPin(readerId: string, data: OptionalPin, callback?: (error: RestException, data: DataResponse) => void): any;
    updateAuthConnection(cfg: GCLConfig): void;
}
export { GCLClient, GCLConfig };

class RestException {
    status: number;
    code: string;
    description: string;
    constructor(status: number, code: string, description: string);
}
export { RestException };

class GCLConfig implements GCLConfig {
    constructor(dsUriValue?: string, apiKey?: string, pkcs11Config?: ModuleConfig);
    ocvUrl: string;
    gclUrl: string;
    dsUrl: string;
    apiKey: string;
    allowAutoUpdate: boolean;
    client_id: string;
    client_secret: string;
    citrix: boolean;
    agentPort: number;
    implicitDownload: boolean;
    readonly dsFileDownloadUrl: string;
    readonly dsUrlBase: string;
    localTestMode: boolean;
    forceHardwarePinpad: boolean;
    defaultSessionTimeout: number;
    tokenCompatible: boolean;
    v2Compatible: boolean;
    defaultConsentDuration: number;
    defaultConsentTimeout: number;
    syncManaged: boolean;
    pkcs11Config: ModuleConfig;
    osPinDialog: boolean;
    containerDownloadTimeout: number;
    readonly gwJwt: Promise<string>;
    gclJwt: string;
    getGwJwt(): Promise<string>;
}
export { GCLConfig };

export { CoreService };
class CoreService implements CoreModel.AbstractCore {
    constructor(url: string, connection: LocalAuthConnection);
    getConsent(title: string, codeWord: string, durationInDays?: number, alertLevel?: string, alertPosition?: string, type?: string, timeoutInSeconds?: number, callback?: (error: CoreExceptions.RestException, data: CoreModel.BoolDataResponse) => void): Promise<CoreModel.BoolDataResponse>;
    info(callback?: (error: CoreExceptions.RestException, data: CoreModel.InfoResponse) => void): Promise<CoreModel.InfoResponse>;
    infoBrowser(callback?: (error: CoreExceptions.RestException, data: CoreModel.BrowserInfoResponse) => void): Promise<CoreModel.BrowserInfoResponse>;
    pollCardInserted(secondsToPollCard?: number, callback?: (error: CoreExceptions.RestException, data: CardReader) => void, connectReaderCb?: () => void, insertCardCb?: () => void, cardTimeoutCb?: () => void): Promise<CardReader>;
    pollReadersWithCards(secondsToPollCard?: number, callback?: (error: CoreExceptions.RestException, data: CoreModel.CardReadersResponse) => void, connectReaderCb?: () => void, insertCardCb?: () => void, cardTimeoutCb?: () => void): Promise<CoreModel.CardReadersResponse>;
    pollReaders(secondsToPollReader?: number, callback?: (error: CoreExceptions.RestException, data: CoreModel.CardReadersResponse) => void, connectReaderCb?: () => void, readerTimeoutCb?: () => void): Promise<CoreModel.CardReadersResponse>;
    reader(reader_id: string, callback?: (error: CoreExceptions.RestException, data: CoreModel.SingleReaderResponse) => void): Promise<CoreModel.SingleReaderResponse>;
    readers(callback?: (error: CoreExceptions.RestException, data: CoreModel.CardReadersResponse) => void): Promise<CoreModel.CardReadersResponse>;
    readersCardAvailable(callback?: (error: CoreExceptions.RestException, data: CoreModel.CardReadersResponse) => void): Promise<CoreModel.CardReadersResponse>;
    readersCardsUnavailable(callback?: (error: CoreExceptions.RestException, data: CoreModel.CardReadersResponse) => void): Promise<CoreModel.CardReadersResponse>;
    infoBrowserSync(): CoreModel.BrowserInfoResponse;
    getUrl(): string;
    version(): Promise<string>;
}

export { AbstractDSClient, DSInfoResponse, DownloadLinkResponse, JWTResponse, DSPubKeyResponse, DeviceResponse, DSPlatformInfo, DSRegistrationOrSyncRequest, DSBrowser, DSOperatingSystem, DSContainer, DSStorage };
interface AbstractDSClient {
    getUrl(): string;
    getInfo(callback?: (error: RestException, data: DSInfoResponse) => void): Promise<DSInfoResponse>;
    getDevice(uuid: string, callback?: (error: RestException, data: DeviceResponse) => void): Promise<DeviceResponse>;
    getPubKey(deviceId: string, callback?: (error: RestException, data: DSPubKeyResponse) => void): Promise<DSPubKeyResponse>;
    downloadLink(infoBrowser: BrowserInfo, callback?: (error: RestException, data: DownloadLinkResponse) => void): Promise<DownloadLinkResponse>;
    register(registrationData: DSRegistrationOrSyncRequest, callback?: (error: RestException, data: DeviceResponse) => void): Promise<DeviceResponse>;
    sync(syncData: DSRegistrationOrSyncRequest, callback?: (error: RestException, data: DeviceResponse) => void): Promise<DeviceResponse>;
}
class DSBrowser {
    name: string;
    version: string;
    constructor(name: string, version: string);
}
class DSOperatingSystem {
    architecture: number;
    name: string;
    version: string;
    constructor(architecture: number, name: string, version: string);
}
class DSRegistrationOrSyncRequest {
    managed: boolean;
    activated: boolean;
    uuid: string;
    version: string;
    derEncodedPublicKey: string;
    manufacturer: string;
    browser: DSBrowser;
    os: DSOperatingSystem;
    ua: string;
    proxyDomain: string;
    containerStates: T1CContainer[];
    constructor(managed: boolean, activated: boolean, uuid: string, version: string, derEncodedPublicKey: string, manufacturer: string, browser: DSBrowser, os: DSOperatingSystem, ua: string, proxyDomain: string, containerStates?: T1CContainer[]);
}
class DSInfoResponse {
    configFile: string;
    build: string;
    version: string;
    environemnt: string;
    storageAppName: string;
    storageServiceAccount: string;
    storageCertPath: string;
    storageBucket: string;
    storageDownloadPrefix: string;
    fileOsx: string;
    fileWin32: string;
    fileWin64: string;
    fileDefaultVersion: string;
    securityEnabled: string;
    securityPrivateKeyAvailable: boolean;
    constructor(configFile: string, build: string, version: string, environemnt: string, storageAppName: string, storageServiceAccount: string, storageCertPath: string, storageBucket: string, storageDownloadPrefix: string, fileOsx: string, fileWin32: string, fileWin64: string, fileDefaultVersion: string, securityEnabled: string, securityPrivateKeyAvailable: boolean);
}
class DownloadLinkResponse implements T1CResponse {
    url: string;
    success: boolean;
    constructor(url: string, success: boolean);
}
class JWTResponse {
    token: string;
    constructor(token: string);
}
class DSPubKeyResponse implements T1CResponse {
    encryptedPublicKey: string;
    encryptedAesKey: string;
    success: boolean;
    constructor(encryptedPublicKey: string, encryptedAesKey: string, success: boolean);
}
class DeviceResponse {
    uuid: string;
    activated: boolean;
    managed: boolean;
    coreVersion: string;
    containerResponses: DSContainer[];
    constructor(uuid: string, activated: boolean, managed: boolean, coreVersion: string, containerResponses: DSContainer[]);
}
class DSContainer {
    id: string;
    name: string;
    version: string;
    osStorage: DSStorage[];
    language: string;
    availability: string;
    dependsOn: string[];
    status: string;
    constructor(id: string, name: string, version: string, osStorage: DSStorage[], language: string, availability: string, dependsOn: string[], status: string);
}
class DSStorage {
    hash: string;
    storagePath: string;
    os: string;
    constructor(hash: string, storagePath: string, os: string);
}
class DSPlatformInfo extends BrowserInfo {
    activated: boolean;
    managed: boolean;
    bi: BrowserInfo;
    core_version: string;
    constructor(activated: boolean, managed: boolean, bi: BrowserInfo, core_version: string);
}

export { DSClient };
class DSClient implements AbstractDSClient {
    constructor(url: string, connection: Connection, cfg: GCLConfig);
    getUrl(): string;
    getInfo(callback?: (error: CoreExceptions.RestException, data: DSInfoResponse) => void): Promise<DSInfoResponse>;
    getDevice(uuid: string, callback?: (error: CoreExceptions.RestException, data: DeviceResponse) => void): Promise<DeviceResponse>;
    getPubKey(uuid: string, callback?: (error: CoreExceptions.RestException, data: DSPubKeyResponse) => void): Promise<DSPubKeyResponse>;
    downloadLink(infoBrowser: BrowserInfo, callback?: (error: CoreExceptions.RestException, data: DownloadLinkResponse) => void): Promise<DownloadLinkResponse>;
    register(registrationData: DSRegistrationOrSyncRequest, callback?: (error: CoreExceptions.RestException, data: DeviceResponse) => void): Promise<DeviceResponse>;
    sync(syncData: DSRegistrationOrSyncRequest, callback?: (error: CoreExceptions.RestException, data: DeviceResponse) => void): Promise<DeviceResponse>;
}

export { AbstractOCVClient, OCVClient };
class OCVClient implements AbstractOCVClient {
    constructor(url: string, connection: RemoteConnection);
    getUrl(): string;
    validateSignature(data: SignatureValidationData, callback?: (error: RestException, data: SignatureValidationResponse) => void): void | Promise<SignatureValidationResponse>;
    getInfo(callback?: (error: RestException, data: OCVInfoResponse) => void): void | Promise<OCVInfoResponse>;
    getChallenge(digestAlgorithm: string, callback?: (error: RestException, data: ChallengeResponse) => void): void | Promise<ChallengeResponse>;
    validateChallengeSignedHash(data: ChallengeSignedHashData, callback?: (error: RestException, data: ChallengeSignedHashResponse) => void): void | Promise<ChallengeSignedHashResponse>;
    validateCertificateChain(data: CertificateChainData, callback?: (error: RestException, data: CertificateChainResponse) => void): void | Promise<CertificateChainResponse>;
}

export { AbstractCore, T1CResponse, BoolDataResponse, DataResponse, DataArrayResponse, DataObjectResponse, InfoResponse, BrowserInfo, BrowserInfoResponse, Card, CardReader, CardReadersResponse, T1CCertificate, CertificateResponse, CertificatesResponse, SingleReaderResponse, T1CContainer, T1CInfo };
interface AbstractCore {
    getConsent(title: string, codeWord: string, durationInDays?: number, alertLevel?: string, alertPosition?: string, type?: string, timeoutInSeconds?: number, callback?: (error: CoreExceptions.RestException, data: BoolDataResponse) => void): Promise<BoolDataResponse>;
    info(callback?: (error: CoreExceptions.RestException, data: InfoResponse) => void): void | Promise<InfoResponse>;
    infoBrowser(callback?: (error: CoreExceptions.RestException, data: BrowserInfoResponse) => void): Promise<BrowserInfoResponse>;
    pollCardInserted(secondsToPollCard?: number, callback?: (error: CoreExceptions.RestException, data: CardReader) => void, connectReader?: () => void, insertCard?: () => void, cardTimeout?: () => void): Promise<CardReader>;
    pollReadersWithCards(secondsToPollCard?: number, callback?: (error: CoreExceptions.RestException, data: CardReadersResponse) => void, connectReader?: () => void, insertCard?: () => void, cardTimeout?: () => void): Promise<CardReadersResponse>;
    pollReaders(secondsToPollReader?: number, callback?: (error: CoreExceptions.RestException, data: CardReadersResponse) => void, connectReader?: () => void, readerTimeout?: () => void): Promise<CardReadersResponse>;
    reader(reader_id: string, callback?: (error: CoreExceptions.RestException, data: SingleReaderResponse) => void): Promise<SingleReaderResponse>;
    readers(callback?: (error: CoreExceptions.RestException, data: CardReadersResponse) => void): Promise<CardReadersResponse>;
    readersCardAvailable(callback?: (error: CoreExceptions.RestException, data: CardReadersResponse) => void): Promise<CardReadersResponse>;
    readersCardsUnavailable(callback?: (error: CoreExceptions.RestException, data: CardReadersResponse) => void): Promise<CardReadersResponse>;
    getUrl(): string;
    infoBrowserSync(): BrowserInfoResponse;
    version(): Promise<string>;
}
class T1CResponse {
    success: boolean;
    data: any;
    constructor(success: boolean, data?: any);
}
class BoolDataResponse extends T1CResponse {
    data: boolean;
    success: boolean;
    constructor(data: boolean, success: boolean);
}
class DataResponse extends T1CResponse {
    data: string;
    success: boolean;
    constructor(data: string, success: boolean);
}
class DataArrayResponse extends T1CResponse {
    data: string[];
    success: boolean;
    constructor(data: string[], success: boolean);
}
class DataObjectResponse extends T1CResponse {
    data: {
        [key: string]: any;
    };
    success: boolean;
    constructor(data: {
        [key: string]: any;
    }, success: boolean);
}
class InfoResponse extends T1CResponse {
    data: T1CInfo;
    success: boolean;
    constructor(data: T1CInfo, success: boolean);
}
class T1CInfo {
    activated: boolean;
    citrix: boolean;
    managed: boolean;
    arch: string;
    os: string;
    uid: string;
    containers: T1CContainer[];
    version: string;
    constructor(activated: boolean, citrix: boolean, managed: boolean, arch: string, os: string, uid: string, containers: T1CContainer[], version: string);
}
class T1CContainer {
    name: string;
    version: string;
    status: string;
    constructor(name: string, version: string, status: string);
}
class BrowserInfoResponse extends T1CResponse {
    data: BrowserInfo;
    success: boolean;
    constructor(data: BrowserInfo, success: boolean);
}
class BrowserInfo {
    browser: {
        name: string;
        version: string;
    };
    manufacturer: string;
    os: {
        name: string;
        version: string;
        architecture: number;
    };
    ua: string;
    constructor(browser: {
        name: string;
        version: string;
    }, manufacturer: string, os: {
        name: string;
        version: string;
        architecture: number;
    }, ua: string);
}
class Card {
    atr: string;
    description: string[];
    constructor(atr: string, description: string[]);
}
class CardReader {
    id: string;
    name: string;
    pinpad: boolean;
    card: Card;
    constructor(id: string, name: string, pinpad: boolean, card?: Card);
}
class CardReadersResponse extends T1CResponse {
    data: CardReader[];
    success: boolean;
    constructor(data: CardReader[], success: boolean);
}
class CertificateResponse extends T1CResponse {
    data: T1CCertificate;
    success: boolean;
    constructor(data: T1CCertificate, success: boolean);
}
class CertificatesResponse extends T1CResponse {
    data: T1CCertificate[];
    success: boolean;
    constructor(data: T1CCertificate[], success: boolean);
}
class T1CCertificate {
    base64: string;
    parsed: object;
    constructor(base64: string, parsed?: object);
}
class SingleReaderResponse extends T1CResponse {
    data: CardReader;
    success: boolean;
    constructor(data: CardReader, success: boolean);
}

export { AbstractEidBE, Address, AddressResponse, AllCertsResponse, AllDataResponse, RnData, RnDataResponse, AllBeIDData, AllBeIDCerts };
interface AbstractEidBE extends CertCard {
    allData(filters: string[] | Options, callback?: (error: RestException, data: AllDataResponse) => void): Promise<AllDataResponse>;
    allCerts(filters: string[] | Options, callback?: (error: RestException, data: AllCertsResponse) => void): Promise<AllCertsResponse>;
    rnData(callback?: (error: RestException, data: RnDataResponse) => void): Promise<RnDataResponse>;
    address(callback?: (error: RestException, data: AddressResponse) => void): Promise<AddressResponse>;
    picture(callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    rootCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    citizenCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    authenticationCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    nonRepudiationCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    rrnCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    verifyPin(body: OptionalPin, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
}
declare class AddressResponse extends DataObjectResponse {
    data: Address;
    success: boolean;
    constructor(data: Address, success: boolean);
}
declare class Address {
    municipality: string;
    raw_data: string;
    signature: string;
    street_and_number: string;
    version: number;
    zipcode: string;
    constructor(municipality: string, raw_data: string, signature: string, street_and_number: string, version: number, zipcode: string);
}
declare class AllCertsResponse extends DataObjectResponse {
    data: AllBeIDCerts;
    success: boolean;
    constructor(data: AllBeIDCerts, success: boolean);
}
declare class AllBeIDCerts {
    authentication_certificate: T1CCertificate;
    citizen_certificate: T1CCertificate;
    non_repudiation_certificate: T1CCertificate;
    root_certificate: T1CCertificate;
    rrn_certificate: T1CCertificate;
    constructor(authentication_certificate?: T1CCertificate, citizen_certificate?: T1CCertificate, non_repudiation_certificate?: T1CCertificate, root_certificate?: T1CCertificate, rrn_certificate?: T1CCertificate);
}
declare class AllDataResponse extends AllCertsResponse {
    data: AllBeIDData;
    success: boolean;
    constructor(data: AllBeIDData, success: boolean);
}
declare class AllBeIDData {
    address: Address;
    authentication_certificate: T1CCertificate;
    citizen_certificate: T1CCertificate;
    non_repudiation_certificate: T1CCertificate;
    picture: string;
    rn: RnData;
    root_certificate: T1CCertificate;
    rrn_certificate: T1CCertificate;
    constructor(address?: Address, authentication_certificate?: T1CCertificate, citizen_certificate?: T1CCertificate, non_repudiation_certificate?: T1CCertificate, picture?: string, rn?: RnData, root_certificate?: T1CCertificate, rrn_certificate?: T1CCertificate);
}
declare class RnData {
    birth_date: string;
    birth_location: string;
    card_delivery_municipality: string;
    card_number: string;
    card_validity_date_begin: string;
    card_validity_date_end: string;
    chip_number: string;
    document_type: string;
    first_names: string;
    name: string;
    national_number: string;
    nationality: string;
    noble_condition: string;
    picture_hash: string;
    raw_data: string;
    sex: string;
    signature: string;
    special_status: string;
    third_name: string;
    version: number;
    constructor(birth_date: string, birth_location: string, card_delivery_municipality: string, card_number: string, card_validity_date_begin: string, card_validity_date_end: string, chip_number: string, document_type: string, first_names: string, name: string, national_number: string, nationality: string, noble_condition: string, picture_hash: string, raw_data: string, sex: string, signature: string, special_status: string, third_name: string, version: number);
}
declare class RnDataResponse extends DataObjectResponse {
    data: RnData;
    success: boolean;
    constructor(data: RnData, success: boolean);
}

export { AbstractEMV, AllDataResponse, ApplicationDataResponse, ApplicationsResponse, EmvCertificateResponse, ApplicationData, Application, EmvCertificate };
interface AbstractEMV extends PinCard {
    allData(filters: string[], callback?: (error: RestException, data: AllDataResponse) => void): Promise<AllDataResponse>;
    applications(callback?: (error: RestException, data: ApplicationsResponse) => void): Promise<ApplicationsResponse>;
    applicationData(callback?: (error: RestException, data: ApplicationDataResponse) => void): Promise<ApplicationDataResponse>;
    iccPublicKeyCertificate(aid: string, callback?: (error: RestException, data: EmvCertificateResponse) => void): Promise<EmvCertificateResponse>;
    issuerPublicKeyCertificate(aid: string, callback?: (error: RestException, data: EmvCertificateResponse) => void): Promise<EmvCertificateResponse>;
}
declare class AllDataResponse extends DataObjectResponse {
    data: {
        applications: Application[];
        application_data: ApplicationData;
    };
    success: boolean;
    constructor(data: {
        applications: Application[];
        application_data: ApplicationData;
    }, success: boolean);
}
declare class Application {
    aid: string;
    name: string;
    priority: number;
    constructor(aid: string, name: string, priority: number);
}
declare class ApplicationsResponse extends DataObjectResponse {
    data: Application[];
    success: boolean;
    constructor(data: Application[], success: boolean);
}
declare class ApplicationData {
    country: string;
    country_code: string;
    effective_data: string;
    expiration_date: string;
    language: string;
    pan: string;
    name: string;
    constructor(country: string, country_code: string, effective_data: string, expiration_date: string, language: string, pan: string, name?: string);
}
declare class ApplicationDataResponse extends DataObjectResponse {
    data: ApplicationData;
    success: boolean;
    constructor(data: ApplicationData, success: boolean);
}
declare class EmvCertificate {
    data: string;
    exponent: string;
    remainder: string;
    constructor(data: string, exponent: string, remainder: string);
}
declare class EmvCertificateResponse extends DataObjectResponse {
    data: EmvCertificate;
    success: boolean;
    constructor(data: EmvCertificate, success: boolean);
}

export { AbstractOcra, AllDataResponse, ChallengeData, ReadCounterResponse, AllOcraData };
interface AbstractOcra extends PinCard {
    allData(filters: string[], callback?: (error: RestException, data: AllDataResponse) => void): Promise<AllDataResponse>;
    challenge(body: ChallengeData, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    readCounter(body: OptionalPin, callback?: (error: RestException, data: ReadCounterResponse) => void): Promise<ReadCounterResponse>;
}
declare class AllDataResponse extends DataObjectResponse {
    data: AllOcraData;
    success: boolean;
    constructor(data: AllOcraData, success: boolean);
}
declare class AllOcraData {
    counter: string;
    constructor(counter: string);
}
declare class ChallengeData extends OptionalPin {
    challenge: string;
    pin: string;
    pace: string;
    constructor(challenge: string, pin?: string, pace?: string);
}
declare class ReadCounterResponse {
    counter: string;
    success: boolean;
    constructor(counter: string, success: boolean);
}

export { AbstractAventra, AllCertsResponse, AllDataResponse, AllAventraCerts, AllAventraData, AppletInfo };
interface AbstractAventra extends CertCard {
    allDataFilters(): string[];
    allCertFilters(): string[];
    allKeyRefs(): string[];
    allAlgoRefsForAuthentication(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    allAlgoRefsForSigning(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    allData(filters: string[], callback?: (error: RestException, data: AllDataResponse) => void): Promise<AllDataResponse>;
    allCerts(filters: string[], callback?: (error: RestException, data: AllCertsResponse) => void): Promise<AllCertsResponse>;
    rootCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    issuerCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    authenticationCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    signingCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    encryptionCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    verifyPin(body: VerifyPinData, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    resetPin(body: ResetPinData, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
}
declare class AllCertsResponse extends DataObjectResponse {
    data: AllAventraCerts;
    success: boolean;
    constructor(data: AllAventraCerts, success: boolean);
}
declare class AllAventraCerts {
    authentication_certificate: T1CCertificate;
    encryption_certificate: T1CCertificate;
    issuer_certificate: T1CCertificate;
    signing_certificate: T1CCertificate;
    root_certificate: T1CCertificate;
    constructor(authentication_certificate: T1CCertificate, encryption_certificate: T1CCertificate, issuer_certificate: T1CCertificate, signing_certificate: T1CCertificate, root_certificate: T1CCertificate);
}
declare class AllDataResponse extends AllCertsResponse {
    data: AllAventraData;
    success: boolean;
    constructor(data: AllAventraData, success: boolean);
}
declare class AllAventraData {
    applet_info: AppletInfo;
    authentication_certificate: T1CCertificate;
    encryption_certificate: T1CCertificate;
    issuer_certificate: T1CCertificate;
    signing_certificate: T1CCertificate;
    root_certificate: T1CCertificate;
    constructor(applet_info: AppletInfo, authentication_certificate: T1CCertificate, encryption_certificate: T1CCertificate, issuer_certificate: T1CCertificate, signing_certificate: T1CCertificate, root_certificate: T1CCertificate);
}
declare class AppletInfo {
    change_counter: number;
    name: string;
    serial: string;
    version: string;
    constructor(change_counter: number, name: string, serial: string, version: string);
}

export { AbstractLuxTrust, AllCertsResponse, AllDataResponse, AllLuxTrustCerts };
interface AbstractLuxTrust extends CertCard {
    activated(callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    allData(filters: string[], callback?: (error: RestException, data: AllDataResponse) => void): Promise<AllDataResponse>;
    allCerts(filters: string[], callback?: (error: RestException, data: AllCertsResponse) => void): Promise<AllCertsResponse>;
    rootCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    authenticationCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    signingCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
}
declare class AllCertsResponse extends DataObjectResponse {
    data: AllLuxTrustCerts;
    success: boolean;
    constructor(data: AllLuxTrustCerts, success: boolean);
}
declare class AllLuxTrustCerts {
    authentication_certificate: T1CCertificate;
    non_repudiation_certificate: T1CCertificate;
    root_certificate: T1CCertificate[];
    constructor(authentication_certificate: T1CCertificate, non_repudiation_certificate: T1CCertificate, root_certificate: T1CCertificate[]);
}
declare class AllDataResponse extends AllCertsResponse {
    data: AllLuxTrustCerts;
    success: boolean;
    constructor(data: AllLuxTrustCerts, success: boolean);
}

export { AbstractOberthur, AllCertsResponse, AllDataResponse, AllOberthurCerts };
interface AbstractOberthur extends CertCard {
    allDataFilters(): string[];
    allCertFilters(): string[];
    allKeyRefs(): string[];
    allAlgoRefsForAuthentication(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    allAlgoRefsForSigning(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    allData(filters: string[], callback?: (error: RestException, data: AllDataResponse) => void): Promise<AllDataResponse>;
    allCerts(filters: string[], callback?: (error: RestException, data: AllCertsResponse) => void): Promise<AllCertsResponse>;
    rootCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    issuerCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    authenticationCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    signingCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    encryptionCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    verifyPin(body: VerifyPinData, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
}
declare class AllCertsResponse extends DataObjectResponse {
    data: AllOberthurCerts;
    success: boolean;
    constructor(data: AllOberthurCerts, success: boolean);
}
declare class AllOberthurCerts {
    root_certificate: T1CCertificate;
    issuer_certificate: T1CCertificate;
    authentication_certificate: T1CCertificate;
    signing_certificate: T1CCertificate;
    encryption_certificate: T1CCertificate;
    constructor(root_certificate: T1CCertificate, issuer_certificate: T1CCertificate, authentication_certificate: T1CCertificate, signing_certificate: T1CCertificate, encryption_certificate: T1CCertificate);
}
declare class AllDataResponse extends AllCertsResponse {
    data: AllOberthurCerts;
    success: boolean;
    constructor(data: AllOberthurCerts, success: boolean);
}

export { AbstractPiv, AllCertsResponse, AllDataResponse, PrintedInformation, PrintedInformationResponse, FacialImage, FacialImageResponse, AllPivCerts, AllPivData };
interface AbstractPiv extends GenericSecuredCertCard {
    allDataFilters(): string[];
    allCertFilters(): string[];
    allKeyRefs(): string[];
    printedInformation(body: OptionalPin, callback?: (error: RestException, data: PrintedInformationResponse) => void): Promise<PrintedInformationResponse>;
    facialImage(body: OptionalPin, callback?: (error: RestException, data: FacialImageResponse) => void): Promise<FacialImageResponse>;
    allData(filters: string[], body: OptionalPin, callback?: (error: RestException, data: AllDataResponse) => void): Promise<AllDataResponse>;
    allCerts(filters: string[], body: OptionalPin, callback?: (error: RestException, data: AllCertsResponse) => void): Promise<AllCertsResponse>;
    authenticationCertificate(body: OptionalPin, options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    signingCertificate(body: OptionalPin, options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
}
declare class PrintedInformationResponse extends DataObjectResponse {
    data: PrintedInformation;
    success: boolean;
    constructor(data: PrintedInformation, success: boolean);
}
declare class PrintedInformation {
    name: string;
    employee_affiliation: string;
    expiration_date: string;
    agency_card_serial_number: any;
    issuer_identification: string;
    organization_affiliation_line_1: string;
    organization_affiliation_line_2: string;
    constructor(name: string, employee_affiliation: string, expiration_date: string, agency_card_serial_number: any, issuer_identification: string, organization_affiliation_line_1: string, organization_affiliation_line_2: string);
}
declare class FacialImageResponse extends DataObjectResponse {
    data: FacialImage;
    success: boolean;
    constructor(data: FacialImage, success: boolean);
}
declare class FacialImage {
    image: string;
    constructor(image: string);
}
declare class AllCertsResponse extends DataObjectResponse {
    data: AllPivCerts;
    success: boolean;
    constructor(data: AllPivCerts, success: boolean);
}
declare class AllPivCerts {
    authentication_certificate: T1CCertificate;
    signing_certificate: T1CCertificate;
    constructor(authentication_certificate: T1CCertificate, signing_certificate: T1CCertificate);
}
declare class AllDataResponse extends AllCertsResponse {
    data: AllPivData;
    success: boolean;
    constructor(data: AllPivData, success: boolean);
}
declare class AllPivData {
    printed_information: PrintedInformation;
    authentication_certificate: T1CCertificate;
    signing_certificate: T1CCertificate;
    facial_image: FacialImage;
    constructor(printed_information: PrintedInformation, authentication_certificate: T1CCertificate, signing_certificate: T1CCertificate, facial_image: FacialImage);
}

export { AbstractMobib, AllDataResponse, StatusResponse, CardIssuing, CardIssuingResponse, Contract, ContractsResponse };
interface AbstractMobib extends Card {
    allData(filters: string[], callback?: (error: RestException, data: AllDataResponse) => void): Promise<AllDataResponse>;
    cardIssuing(callback?: (error: RestException, data: CardIssuingResponse) => void): Promise<CardIssuingResponse>;
    contracts(callback?: (error: RestException, data: ContractsResponse) => void): Promise<ContractsResponse>;
    picture(callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    status(callback?: (error: RestException, data: StatusResponse) => void): Promise<StatusResponse>;
}
declare class AllDataResponse extends DataObjectResponse {
    data: {
        active: boolean;
        'card-issuing': CardIssuing;
        contracts: Contract[];
        picture: string;
    };
    success: boolean;
    constructor(data: {
        active: boolean;
        'card-issuing': CardIssuing;
        contracts: Contract[];
        picture: string;
    }, success: boolean);
}
declare class StatusResponse extends DataObjectResponse {
    data: {
        active: boolean;
    };
    success: boolean;
    constructor(data: {
        active: boolean;
    }, success: boolean);
}
declare class CardIssuing {
    card_expiration_date: string;
    card_holder_birth_date: string;
    card_holder_end_date: string;
    card_holder_id: string;
    card_holder_name: string;
    card_holder_start_date: string;
    card_revalidation_date: string;
    card_type: number;
    company_id: number;
    gender: number;
    language: number;
    version: number;
    constructor(card_expiration_date: string, card_holder_birth_date: string, card_holder_end_date: string, card_holder_id: string, card_holder_name: string, card_holder_start_date: string, card_revalidation_date: string, card_type: number, company_id: number, gender: number, language: number, version: number);
}
declare class CardIssuingResponse extends DataObjectResponse {
    data: CardIssuing;
    success: boolean;
    constructor(data: CardIssuing, success: boolean);
}
declare class Contract {
    authenticator_kvc: number;
    authenticator_value: number;
    journey_interchanges_allowed: boolean;
    passengers_max: number;
    period_journeys: {
        max_number_of_trips: number;
        period: number;
    };
    price_amount: number;
    provider: number;
    restrict_code: number;
    restrict_time: number;
    sale_date: string;
    sale_sam_count: number;
    sale_sam_id: number;
    spatials: {
        type: number;
    }[];
    tariff: {
        counter: {
            time: string;
            type: number;
        };
        multimodal: boolean;
        nameref: number;
    };
    validity_duration: {
        unit: number;
        value: number;
    };
    validity_start_date: string;
    vehicle_class_allowed: number;
    version: number;
    constructor(authenticator_kvc: number, authenticator_value: number, journey_interchanges_allowed: boolean, passengers_max: number, period_journeys: {
        max_number_of_trips: number;
        period: number;
    }, price_amount: number, provider: number, restrict_code: number, restrict_time: number, sale_date: string, sale_sam_count: number, sale_sam_id: number, spatials: {
        type: number;
    }[], tariff: {
        counter: {
            time: string;
            type: number;
        };
        multimodal: boolean;
        nameref: number;
    }, validity_duration: {
        unit: number;
        value: number;
    }, validity_start_date: string, vehicle_class_allowed: number, version: number);
}
declare class ContractsResponse extends DataObjectResponse {
    data: Contract[];
    success: boolean;
    constructor(data: Contract[], success: boolean);
}

export { AbstractEidLUX, AllCertsResponse, AllDataResponse, Biometric, BiometricResponse, Picture, PictureResponse, SignatureImage, SignatureImageResponse, AllLuxData, AllLuxCerts };
interface AbstractEidLUX extends SecuredCertCard {
    allDataFilters(): string[];
    allCertFilters(): string[];
    allData(options?: string[] | Options, callback?: (error: RestException, data: AllDataResponse) => void): Promise<AllDataResponse>;
    allCerts(options?: string[] | Options, callback?: (error: RestException, data: AllCertsResponse) => void): Promise<AllCertsResponse>;
    biometric(callback?: (error: RestException, data: BiometricResponse) => void): Promise<BiometricResponse>;
    picture(callback?: (error: RestException, data: PictureResponse) => void): Promise<PictureResponse>;
    rootCertificate(options?: Options, callback?: (error: RestException, data: CertificatesResponse) => void): Promise<CertificatesResponse>;
    authenticationCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    nonRepudiationCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    signatureImage(callback?: (error: RestException, data: SignatureImageResponse) => void): Promise<SignatureImageResponse>;
}
declare class AllCertsResponse extends DataObjectResponse {
    data: AllLuxCerts;
    success: boolean;
    constructor(data: AllLuxCerts, success: boolean);
}
declare class AllLuxCerts {
    authentication_certificate: T1CCertificate;
    non_repudiation_certificate: T1CCertificate;
    root_certificates: T1CCertificate[];
    constructor(authentication_certificate: T1CCertificate, non_repudiation_certificate: T1CCertificate, root_certificates: T1CCertificate[]);
}
declare class AllDataResponse extends AllCertsResponse {
    data: AllLuxData;
    success: boolean;
    constructor(data: AllLuxData, success: boolean);
}
declare class AllLuxData extends AllLuxCerts {
    authentication_certificate: T1CCertificate;
    non_repudiation_certificate: T1CCertificate;
    root_certificates: T1CCertificate[];
    biometric: Biometric;
    picture: Picture;
    signature_image: SignatureImage;
    signature_object: string;
    constructor(authentication_certificate: T1CCertificate, non_repudiation_certificate: T1CCertificate, root_certificates: T1CCertificate[], biometric: Biometric, picture: Picture, signature_image: SignatureImage, signature_object: string);
}
declare class Biometric {
    birthData: string;
    documentNumber: string;
    documentType: string;
    firstName: string;
    gender: string;
    issuingState: string;
    lastName: string;
    nationality: string;
    validityEndData: string;
    validityStartData: string;
    constructor(birthData: string, documentNumber: string, documentType: string, firstName: string, gender: string, issuingState: string, lastName: string, nationality: string, validityEndData: string, validityStartData: string);
}
declare class BiometricResponse extends DataObjectResponse {
    data: Biometric;
    success: boolean;
    constructor(data: Biometric, success: boolean);
}
declare class Picture {
    height: number;
    width: number;
    image: string;
    raw_data: string;
    constructor(height: number, width: number, image: string, raw_data: string);
}
declare class PictureResponse extends DataObjectResponse {
    data: Picture;
    success: boolean;
    constructor(data: Picture, success: boolean);
}
declare class SignatureImage {
    image: string;
    raw_data: string;
    constructor(image: string, raw_data: string);
}
declare class SignatureImageResponse extends DataObjectResponse {
    data: SignatureImage;
    success: boolean;
    constructor(data: SignatureImage, success: boolean);
}

export { AbstractDNIe, AllCertsResponse, AllDataResponse, InfoResponse, AllDNIeData, AllDNIeCerts, Info };
interface AbstractDNIe extends SecuredCertCard {
    allData(options: Options, body: OptionalPin, callback?: (error: RestException, data: AllDataResponse) => void): Promise<AllDataResponse>;
    allCerts(options: Options, callback?: (error: RestException, data: AllCertsResponse) => void): Promise<AllCertsResponse>;
    info(callback?: (error: RestException, data: InfoResponse) => void): Promise<InfoResponse>;
    intermediateCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    authenticationCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    signingCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
}
declare class AllCertsResponse extends DataObjectResponse {
    data: AllDNIeCerts;
    success: boolean;
    constructor(data: AllDNIeCerts, success: boolean);
}
declare class AllDNIeCerts {
    authentication_certificate: T1CCertificate;
    intermediate_certificate: T1CCertificate;
    signing_certificate: T1CCertificate;
    constructor(authentication_certificate?: T1CCertificate, intermediate_certificate?: T1CCertificate, signing_certificate?: T1CCertificate);
}
declare class AllDataResponse extends AllCertsResponse {
    data: AllDNIeData;
    success: boolean;
    constructor(data: AllDNIeData, success: boolean);
}
declare class AllDNIeData {
    info: Info;
    authentication_certificate: T1CCertificate;
    intermediate_certificate: T1CCertificate;
    signing_certificate: T1CCertificate;
    constructor(info: Info, authentication_certificate?: T1CCertificate, intermediate_certificate?: T1CCertificate, signing_certificate?: T1CCertificate);
}
declare class InfoResponse extends DataObjectResponse {
    data: Info;
    success: boolean;
    constructor(data: Info, success: boolean);
}
declare class Info {
    first_name: string;
    last_names: string;
    national_number: string;
    card_number: string;
    serial: string;
    constructor(first_name: string, last_names: string, national_number: string, card_number: string, serial: string);
}

export interface AbstractFactory {
    createEidBE(reader_id?: string): AbstractEidBE;
    createEidLUX(reader_id?: string): AbstractEidLUX;
    createEmv(reader_id?: string): AbstractEMV;
    createLuxTrust(reader_id?: string): AbstractLuxTrust;
    createMobib(reader_id?: string): AbstractMobib;
    createOcra(reader_id?: string): AbstractOcra;
    createAventraNO(reader_id?: string): AbstractAventra;
    createOberthurNO(reader_id?: string): AbstractOberthur;
    createPIV(reader_id?: string): AbstractPiv;
    createPKCS11(): AbstractPkcs11;
}
export declare class PluginFactory implements AbstractFactory {
    constructor(url: string, connection: LocalConnection);
    createDNIe(reader_id?: string): AbstractDNIe;
    createEidBE(reader_id?: string): AbstractEidBE;
    createEidLUX(reader_id?: string, pin?: string): AbstractEidLUX;
    createEidPT(reader_id?: string): AbstractEidPT;
    createEmv(reader_id?: string): EMV;
    createLuxTrust(reader_id?: string): LuxTrust;
    createMobib(reader_id?: string): Mobib;
    createOcra(reader_id?: string): Ocra;
    createAventraNO(reader_id?: string): Aventra;
    createOberthurNO(reader_id?: string): Oberthur;
    createPIV(reader_id?: string): PIV;
    createPKCS11(): AbstractPkcs11;
    createRemoteLoading(reader_id?: string): AbstractRemoteLoading;
    createBelfius(reader_id?: string): AbstractBelfius;
    createFileExchange(): AbstractFileExchange;
    createDataContainer(containerPath: string): () => AbstractDataContainer;
}

export { Card, CertCard, PinCard, SecuredCertCard, AuthenticateOrSignData, ResetPinData, VerifyPinData, OptionalPin, GenericContainer, GenericReaderContainer, GenericSmartCard, GenericPinCard, GenericCertCard, GenericSecuredCertCard };
interface Card {
    allData: (filters: string[], callback?: () => void) => Promise<DataObjectResponse>;
}
interface PinCard extends Card {
    verifyPin: (body: VerifyPinData, callback?: () => void) => Promise<T1CResponse>;
}
interface CertCard extends PinCard {
    allCerts: (filters: string[] | Options, callback?: () => void) => Promise<DataObjectResponse>;
    authenticate: (body: any, callback?: () => void) => Promise<DataResponse>;
    signData: (body: any, callback?: () => void) => Promise<DataResponse>;
}
interface SecuredCertCard {
    allCerts: (filters: string[] | Options, body: OptionalPin, callback?: () => void) => Promise<DataObjectResponse>;
    allData: (filters: string[] | Options, body: OptionalPin, callback?: () => void) => Promise<DataObjectResponse>;
    authenticate: (body: any, callback?: () => void) => Promise<DataResponse>;
    signData: (body: any, callback?: () => void) => Promise<DataResponse>;
    verifyPin: (body: OptionalPin, callback?: () => void) => Promise<T1CResponse>;
}
declare class OptionalPin {
    pin: string;
    pace: string;
    constructor(pin?: string, pace?: string);
}
declare class AuthenticateOrSignData extends OptionalPin {
    algorithm_reference: string;
    data: string;
    pin: string;
    pace: string;
    constructor(algorithm_reference: string, data: string, pin?: string, pace?: string);
}
declare class VerifyPinData extends OptionalPin {
    private_key_reference: string;
    pin: string;
    pace: string;
    constructor(private_key_reference: string, pin: string, pace?: string);
}
declare class ResetPinData {
    puk: string;
    new_pin: string;
    private_key_reference: string;
    constructor(puk: string, new_pin: string, private_key_reference: string);
}
declare abstract class GenericContainer {
    protected baseUrl: string;
    protected containerUrl: string;
    protected connection: LocalConnection;
    constructor(baseUrl: string, containerUrl: string, connection: LocalConnection);
    protected containerSuffix(path?: string): string;
}
declare abstract class GenericReaderContainer extends GenericContainer {
    protected baseUrl: string;
    protected containerUrl: string;
    protected connection: LocalConnection;
    protected reader_id: string;
    constructor(baseUrl: string, containerUrl: string, connection: LocalConnection, reader_id: string);
    protected containerSuffix(path?: string): string;
}
declare abstract class GenericSmartCard extends GenericReaderContainer implements Card {
    allData(options: string[] | Options, callback?: (error: RestException, data: DataObjectResponse) => void): Promise<DataObjectResponse>;
}
declare abstract class GenericPinCard extends GenericSmartCard implements PinCard {
    static VERIFY_PIN: string;
    verifyPin(body: OptionalPin, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
}
declare abstract class GenericCertCard extends GenericPinCard implements CertCard {
    static ALL_CERTIFICATES: string;
    static AUTHENTICATE: string;
    static CERT_ROOT: string;
    static CERT_AUTHENTICATION: string;
    static CERT_NON_REPUDIATION: string;
    static CERT_ISSUER: string;
    static CERT_SIGNING: string;
    static CERT_ENCRYPTION: string;
    static CERT_CITIZEN: string;
    static CERT_RRN: string;
    static SIGN_DATA: string;
    allAlgoRefsForAuthentication(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    allAlgoRefsForSigning(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    allCerts(options: string[] | Options, callback?: (error: RestException, data: DataObjectResponse) => void): Promise<DataObjectResponse>;
    authenticate(body: AuthenticateOrSignData, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    signData(body: AuthenticateOrSignData, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    protected getCertificate(certUrl: string, options: RequestOptions): Promise<CertificateResponse>;
}
declare abstract class GenericSecuredCertCard extends GenericReaderContainer implements SecuredCertCard {
    static ALL_CERTIFICATES: string;
    static AUTHENTICATE: string;
    static CERT_AUTHENTICATION: string;
    static CERT_NON_REPUDIATION: string;
    static CERT_INTERMEDIATE: string;
    static CERT_ROOT: string;
    static CERT_SIGNING: string;
    static SIGN_DATA: string;
    static VERIFY_PIN: string;
    allAlgoRefsForAuthentication(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    allAlgoRefsForSigning(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    allData(options: string[] | Options, body: OptionalPin, callback?: (error: RestException, data: DataObjectResponse) => void): Promise<DataObjectResponse>;
    allCerts(options: string[] | Options, body: OptionalPin, callback?: (error: RestException, data: DataObjectResponse) => void): Promise<DataObjectResponse>;
    verifyPin(body: OptionalPin, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    signData(body: AuthenticateOrSignData, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    authenticate(body: AuthenticateOrSignData, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    protected getCertificate(certUrl: string, body: OptionalPin, options: RequestOptions, params?: {
        filter?: string;
        pin?: string;
    }): Promise<CertificateResponse>;
    protected getCertificateArray(certUrl: string, body: OptionalPin, options: RequestOptions, params?: {
        filter?: string;
        pin?: string;
    }): Promise<CertificatesResponse>;
}

export { AbstractEidPT, AllCertsResponse, AllDataResponse, IdDataResponse, PtAddressResponse, AllPtData, AllPtCerts, IdData, PtAddressData };
interface AbstractEidPT extends CertCard {
    allData(filters: string[], callback?: (error: RestException, data: AllDataResponse) => void): Promise<AllDataResponse>;
    allCerts(filters: string[], callback?: (error: RestException, data: AllCertsResponse) => void): Promise<AllCertsResponse>;
    idData(callback?: (error: RestException, data: IdDataResponse) => void): Promise<IdDataResponse>;
    idDataWithOutPhoto(callback?: (error: RestException, data: IdDataResponse) => void): Promise<IdDataResponse>;
    address(data: OptionalPin, callback?: (error: RestException, data: PtAddressResponse) => void): Promise<PtAddressResponse>;
    photo(callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    rootCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    rootAuthenticationCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    rootNonRepudiationCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    authenticationCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    nonRepudiationCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
}
declare class AllCertsResponse extends DataObjectResponse {
    data: AllPtCerts;
    success: boolean;
    constructor(data: AllPtCerts, success: boolean);
}
declare class AllPtCerts {
    authentication_certificate: T1CCertificate;
    non_repudiation_certificate: T1CCertificate;
    root_authentication_certificate: T1CCertificate;
    root_certificate: T1CCertificate;
    root_non_repudiation_certificate: T1CCertificate;
    constructor(authentication_certificate?: T1CCertificate, non_repudiation_certificate?: T1CCertificate, root_authentication_certificate?: T1CCertificate, root_certificate?: T1CCertificate, root_non_repudiation_certificate?: T1CCertificate);
}
declare class AllDataResponse extends AllCertsResponse {
    data: AllPtData;
    success: boolean;
    constructor(data: AllPtData, success: boolean);
}
declare class AllPtData {
    id: IdData;
    authentication_certificate: T1CCertificate;
    non_repudiation_certificate: T1CCertificate;
    root_authentication_certificate: T1CCertificate;
    root_certificate: T1CCertificate;
    root_non_repudiaton_certificate: T1CCertificate;
    constructor(id?: IdData, authentication_certificate?: T1CCertificate, non_repudiation_certificate?: T1CCertificate, root_authentication_certificate?: T1CCertificate, root_certificate?: T1CCertificate, root_non_repudiaton_certificate?: T1CCertificate);
}
declare class IdData {
    accidental_indications: boolean;
    civilian_number: string;
    country: string;
    date_of_birth: string;
    document_number: string;
    document_number_pan: string;
    document_type: string;
    document_version: string;
    gender: string;
    given_name_father: string;
    given_name_mother: string;
    health_no: string;
    height: string;
    issuing_entity: string;
    local_of_request: string;
    mrz1: string;
    mrz2: string;
    mrz3: string;
    name: string;
    nationality: string;
    raw_data: string;
    social_security_no: string;
    surname: string;
    surname_father: string;
    surname_mother: string;
    tax_no: string;
    validity_begin_date: string;
    validity_end_date: string;
    photo: string;
    constructor(accidental_indications: boolean, civilian_number: string, country: string, date_of_birth: string, document_number: string, document_number_pan: string, document_type: string, document_version: string, gender: string, given_name_father: string, given_name_mother: string, health_no: string, height: string, issuing_entity: string, local_of_request: string, mrz1: string, mrz2: string, mrz3: string, name: string, nationality: string, raw_data: string, social_security_no: string, surname: string, surname_father: string, surname_mother: string, tax_no: string, validity_begin_date: string, validity_end_date: string, photo?: string);
}
declare class IdDataResponse extends DataObjectResponse {
    data: IdData;
    success: boolean;
    constructor(data: IdData, success: boolean);
}
declare class PtAddressData {
    abbr_building_type: string;
    abbr_street_type: string;
    building_type: string;
    civil_parish: string;
    civil_parish_description: string;
    district: string;
    district_description: string;
    door_no: string;
    floor: string;
    gen_address_num: string;
    is_national: boolean;
    locality: string;
    municipality: string;
    municipality_description: string;
    place: string;
    postal_locality: string;
    raw_data: string;
    side: string;
    street_name: string;
    street_type: string;
    type: string;
    zip3: string;
    zip4: string;
    constructor(abbr_building_type: string, abbr_street_type: string, building_type: string, civil_parish: string, civil_parish_description: string, district: string, district_description: string, door_no: string, floor: string, gen_address_num: string, is_national: boolean, locality: string, municipality: string, municipality_description: string, place: string, postal_locality: string, raw_data: string, side: string, street_name: string, street_type: string, type: string, zip3: string, zip4: string);
}
declare class PtAddressResponse extends DataObjectResponse {
    data: PtAddressData;
    success: boolean;
    constructor(data: PtAddressData, success: boolean);
}

export { AbstractRemoteLoading, APDU, CommandResponse, CommandsResponse, Command };
interface AbstractRemoteLoading {
    atr(sessionId?: string, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    apdu(apdu: APDU, sessionId?: string, callback?: (error: RestException, data: CommandResponse) => void): Promise<CommandResponse>;
    apdu(apdu: APDU[], sessionId?: string, callback?: (error: RestException, data: CommandsResponse) => void): Promise<CommandsResponse>;
    ccid(feature: string, command: string, sessionId?: string, callback?: (error: RestException, data: CommandResponse) => void): Promise<CommandResponse>;
    ccidFeatures(sessionId?: string, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    command(tx: string, sessionId?: string, callback?: (error: RestException, data: CommandResponse) => void): Promise<CommandResponse>;
    command(tx: string[], sessionId?: string, callback?: (error: RestException, data: CommandsResponse) => void): Promise<CommandsResponse>;
    closeSession(sessionId?: string, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    isPresent(sessionId?: string, callback?: (error: RestException, data: BoolDataResponse) => void): Promise<BoolDataResponse>;
    openSession(timeout?: number, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
}
declare class APDU {
    cla: string;
    ins: string;
    p1: string;
    p2: string;
    data: string;
    le: string;
    constructor(cla: string, ins: string, p1: string, p2: string, data?: string, le?: string);
}
declare class CommandResponse extends T1CResponse {
    data: Command;
    success: boolean;
    constructor(data: Command, success: boolean);
}
declare class CommandsResponse extends T1CResponse {
    data: Command[];
    success: boolean;
    constructor(data: Command[], success: boolean);
}
declare class Command {
    sw: string;
    tx: string;
    rx: string;
    constructor(sw: string, tx: string, rx?: string);
}

export { AbstractBelfius };
interface AbstractBelfius {
    closeSession(sessionId: string, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    isBelfiusReader(sessionId: string, callback?: (error: RestException, data: BoolDataResponse) => void): Promise<BoolDataResponse>;
    nonce(sessionId: string, callback?: (error: RestException, data: CommandResponse) => void): Promise<CommandResponse>;
    openSession(timeout?: number, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    stx(command: string, sessionId: string, callback?: (error: RestException, data: CommandResponse) => void): Promise<CommandResponse>;
}

export { AbstractAgent, AgentResponse, Agent };
interface AbstractAgent {
    get(filters?: {
        [filterParam: string]: string;
    }, callback?: (error: CoreExceptions.RestException, data: AgentResponse) => void): Promise<AgentResponse>;
}
interface AgentResponse extends T1CResponse {
    data: Agent[];
}
class Agent {
    hostname: string;
    port: number;
    last_update: string;
    constructor(hostname: string, port: number, last_update: string);
}

export { AdminService };
class AdminService implements AbstractAdmin {
    static JWT_ERROR_CODES: string[];
    constructor(url: string, connection: LocalAuthConnection);
    activate(callback?: (error: CoreExceptions.RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    getPubKey(callback?: (error: CoreExceptions.RestException, data: PubKeyResponse) => void): Promise<PubKeyResponse>;
    setPubKey(keys: SetPubKeyRequest, callback?: (error: CoreExceptions.RestException, data: PubKeyResponse) => void): Promise<PubKeyResponse>;
    updateContainerConfig(containers: ContainerSyncRequest, callback?: (error: CoreExceptions.RestException, data: T1CResponse) => void): Promise<T1CResponse>;
}

export { AbstractPkcs11, InfoResponse, Pkcs11Certificate, Pkcs11CertificatesResponse, Pkcs11Info, Pkcs11SignData, Pkcs11VerifySignedData, Slot, SlotsResponse, TokenInfo, TokenResponse, ModuleConfig };
interface AbstractPkcs11 {
    certificates(slotId: number, options?: Options, callback?: (error: RestException, data: Pkcs11CertificatesResponse) => void): Promise<Pkcs11CertificatesResponse>;
    info(callback?: (error: RestException, data: InfoResponse) => void): Promise<InfoResponse>;
    signData(data: Pkcs11SignData, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    slots(callback?: (error: RestException, data: SlotsResponse) => void): Promise<SlotsResponse>;
    slotsWithTokenPresent(callback?: (error: RestException, data: SlotsResponse) => void): Promise<SlotsResponse>;
    token(slotId: number, callback?: (error: RestException, data: TokenResponse) => void): Promise<TokenResponse>;
    verifySignedData(data: Pkcs11VerifySignedData, callback?: (error: RestException, data: BoolDataResponse) => void): Promise<BoolDataResponse>;
}
declare class InfoResponse extends DataObjectResponse {
    data: Pkcs11Info;
    success: boolean;
    constructor(data: Pkcs11Info, success: boolean);
}
declare class Pkcs11Info {
    cryptoki_version: string;
    manufacturer_id: string;
    flags: string;
    library_description: string;
    library_version: string;
    constructor(cryptoki_version: string, manufacturer_id: string, flags: string, library_description: string, library_version: string);
}
declare class Slot {
    slot_id: string;
    description: string;
    flags: number;
    hardware_version: string;
    firmware_version: string;
    constructor(slot_id: string, description: string, flags: number, hardware_version: string, firmware_version: string);
}
declare class SlotsResponse extends DataObjectResponse {
    data: Slot[];
    success: boolean;
    constructor(data: Slot[], success: boolean);
}
declare class Pkcs11Certificate extends T1CCertificate {
    id: string;
    base64: string;
    parsed: object;
    constructor(id: string, base64: string, parsed?: object);
}
declare class Pkcs11CertificatesResponse extends CertificatesResponse {
    data: Pkcs11Certificate[];
    success: boolean;
    constructor(data: Pkcs11Certificate[], success: boolean);
}
declare class Pkcs11SignData extends AuthenticateOrSignData {
    slot_id: number;
    cert_id: string;
    algorithm_reference: string;
    data: string;
    pin: string;
    pace: string;
    constructor(slot_id: number, cert_id: string, algorithm_reference: string, data: string, pin?: string, pace?: string);
}
declare class Pkcs11VerifySignedData extends Pkcs11SignData {
    slot_id: number;
    cert_id: string;
    algorithm_reference: string;
    data: string;
    signature: string;
    pin: string;
    pace: string;
    constructor(slot_id: number, cert_id: string, algorithm_reference: string, data: string, signature: string, pin?: string, pace?: string);
}
declare class TokenInfo {
    slot_id: string;
    label: string;
    manufacturer_id: string;
    model: string;
    serial_number: string;
    flags: string;
    max_session_count: number;
    session_count: number;
    max_rw_session_count: number;
    rw_session_count: number;
    max_pin_length: number;
    min_pin_length: number;
    total_public_memory: number;
    free_public_memory: number;
    total_private_memory: number;
    free_private_memory: number;
    hardware_version: string;
    firmware_version: string;
    constructor(slot_id: string, label: string, manufacturer_id: string, model: string, serial_number: string, flags: string, max_session_count: number, session_count: number, max_rw_session_count: number, rw_session_count: number, max_pin_length: number, min_pin_length: number, total_public_memory: number, free_public_memory: number, total_private_memory: number, free_private_memory: number, hardware_version: string, firmware_version: string);
}
declare class TokenResponse extends DataObjectResponse {
    data: TokenInfo;
    success: boolean;
    constructor(data: TokenInfo, success: boolean);
}
declare class ModuleConfig {
    linux: string;
    mac: string;
    win: string;
    constructor(linux: string, mac: string, win: string);
}

export { GenericConnection, LocalConnection, LocalAuthConnection, RemoteConnection, Connection, LocalTestConnection, RequestBody, RequestHeaders, RequestCallback, QueryParams };
interface Connection {
    get(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    post(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    put(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    delete(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
}
interface RequestBody {
    [key: string]: any;
}
interface QueryParams {
    [key: string]: any;
}
interface RequestHeaders {
    [key: string]: string;
}
interface RequestCallback {
    (error: any, data: any): void;
}
abstract class GenericConnection implements Connection {
    cfg: GCLConfig;
    static readonly AUTH_TOKEN_HEADER: string;
    static readonly BROWSER_AUTH_TOKEN: string;
    constructor(cfg: GCLConfig);
    static getSecurityConfig(): {
        sendGwJwt: boolean;
        sendGclJwt: boolean;
        sendApiKey: boolean;
        sendToken: boolean;
    };
    get(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    post(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    put(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    delete(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    getRequestHeaders(headers: RequestHeaders): RequestHeaders;
    protected handleRequest(basePath: string, suffix: string, method: string, gclConfig: GCLConfig, securityConfig: {
        sendGwJwt: boolean;
        sendGclJwt: boolean;
        sendApiKey: boolean;
        sendToken: boolean;
    }, body?: RequestBody, params?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback, skipCitrixCheck?: boolean): Promise<any>;
}
class LocalAuthConnection extends GenericConnection implements Connection {
    cfg: GCLConfig;
    constructor(cfg: GCLConfig);
    static getSecurityConfig(): {
        sendGwJwt: boolean;
        sendGclJwt: boolean;
        sendApiKey: boolean;
        sendToken: boolean;
    };
    get(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    getSkipCitrix(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    post(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    put(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    delete(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
}
class LocalConnection extends GenericConnection implements Connection {
    cfg: GCLConfig;
    constructor(cfg: GCLConfig);
    static getSecurityConfig(): {
        sendGwJwt: boolean;
        sendGclJwt: boolean;
        sendApiKey: boolean;
        sendToken: boolean;
    };
    get(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    getSkipCitrix(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    post(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    put(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    requestFile(basePath: string, suffix: string, body: {
        path: string;
    }, callback?: RequestCallback): Promise<any>;
    putFile(basePath: string, suffix: string, body: RequestBody, queryParams: QueryParams, callback?: RequestCallback): Promise<any>;
    delete(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
}
class RemoteConnection extends GenericConnection implements Connection {
    cfg: GCLConfig;
    constructor(cfg: GCLConfig);
    static getSecurityConfig(): {
        sendGwJwt: boolean;
        sendGclJwt: boolean;
        sendApiKey: boolean;
        sendToken: boolean;
    };
    get(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    post(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    put(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    delete(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
}
class LocalTestConnection extends GenericConnection implements Connection {
    config: any;
    get(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    post(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    put(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    delete(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    getRequestHeaders(headers: RequestHeaders): RequestHeaders;
}

export { AbstractOCVClient, CertificateAndOrder, CertificateChainData, CertificateChainResponse, ChallengeResponse, ChallengeSignedHashResponse, ChallengeSignedHashData, SignatureValidationData, SignatureValidationResponse, OCVInfoResponse };
interface AbstractOCVClient {
    getChallenge(digestAlgorithm: string, callback?: (error: CoreExceptions.RestException, data: ChallengeResponse) => void): void | Promise<ChallengeResponse>;
    validateChallengeSignedHash(data: ChallengeSignedHashData, callback?: (error: CoreExceptions.RestException, data: ChallengeSignedHashResponse) => void): void | Promise<ChallengeSignedHashResponse>;
    validateCertificateChain(data: CertificateChainData, callback?: (error: CoreExceptions.RestException, data: CertificateChainResponse) => void): void | Promise<CertificateChainResponse>;
    validateSignature(data: SignatureValidationData, callback?: (error: CoreExceptions.RestException, data: SignatureValidationResponse) => void): void | Promise<SignatureValidationResponse>;
    getInfo(callback?: (error: CoreExceptions.RestException, data: OCVInfoResponse) => void): void | Promise<OCVInfoResponse>;
}
class ChallengeSignedHashData {
    base64Signature: string;
    base64Certificate: string;
    hash: string;
    digestAlgorithm: string;
    constructor(base64Signature: string, base64Certificate: string, hash: string, digestAlgorithm: string);
}
class SignatureValidationData {
    rawData: string;
    certificate: string;
    signature: string;
    constructor(rawData: string, certificate: string, signature: string);
}
class CertificateChainData {
    certificateChain: CertificateAndOrder[];
    constructor(certificateChain: CertificateAndOrder[]);
}
class CertificateChainResponse {
    crlResponse: {
        crlLocations: string[];
        issuerCertificate: string;
        productionData: string;
        signatureAlgorithm: string;
        status: boolean;
        version: string;
    };
    ocspResponse: {
        ocspLocation: string;
        status: boolean;
    };
    constructor(crlResponse: {
        crlLocations: string[];
        issuerCertificate: string;
        productionData: string;
        signatureAlgorithm: string;
        status: boolean;
        version: string;
    }, ocspResponse: {
        ocspLocation: string;
        status: boolean;
    });
}
class CertificateAndOrder {
    certificate: string;
    order: number;
    constructor(certificate: string, order: number);
}
class ChallengeResponse {
    hash: string;
    digestAlgorithm: string;
    constructor(hash: string, digestAlgorithm: string);
}
class ChallengeSignedHashResponse extends ChallengeResponse {
    result: boolean;
    hash: string;
    digestAlgorithm: string;
    constructor(result: boolean, hash: string, digestAlgorithm: string);
}
class SignatureValidationResponse {
    rawData: string;
    signature: string;
    digest: string;
    signatureAlgorithm: string;
    constructor(rawData: string, signature: string, digest: string, signatureAlgorithm: string, result: string);
}
class OCVInfoResponse {
    configFile: string;
    build: string;
    version: string;
    environemnt: string;
    constructor(configFile: string, build: string, version: string, environemnt: string);
}

export { RequestHandler, Options, RequestOptions };
declare class Options {
    parseCerts: boolean;
    filters: string[];
    constructor(parseCerts: boolean, filters?: string[]);
}
declare class RequestOptions {
    parseCerts: boolean;
    params: {
        [key: string]: string;
    };
    callback: () => void;
    constructor(parseCerts: boolean, params?: {
        [key: string]: string;
    }, callback?: () => void);
}
declare class RequestHandler {
    static determineOptions(firstParam: any, secondParam: any): RequestOptions;
    static determineOptionsWithFilter(firstParam: string[] | Options): RequestOptions;
}

export { EMV };
declare class EMV extends GenericPinCard implements AbstractEMV {
    static APPLICATIONS: string;
    static APPLICATION_DATA: string;
    static ISSUER_PUBLIC_KEY_CERT: string;
    static ICC_PUBLIC_KEY_CERT: string;
    applicationData(callback?: (error: RestException, data: ApplicationDataResponse) => void): Promise<ApplicationDataResponse>;
    applications(callback?: (error: RestException, data: ApplicationsResponse) => void): Promise<ApplicationsResponse>;
    iccPublicKeyCertificate(aid: string, callback?: (error: RestException, data: EmvCertificateResponse) => void): Promise<EmvCertificateResponse>;
    issuerPublicKeyCertificate(aid: string, callback?: (error: RestException, data: EmvCertificateResponse) => void): Promise<EmvCertificateResponse>;
}

export { Mobib };
declare class Mobib extends GenericSmartCard implements AbstractMobib {
    cardIssuing(callback?: (error: RestException, data: CardIssuingResponse) => void): Promise<CardIssuingResponse>;
    contracts(callback?: (error: RestException, data: ContractsResponse) => void): Promise<ContractsResponse>;
    picture(callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    status(callback?: (error: RestException, data: StatusResponse) => void): Promise<StatusResponse>;
}

export { LuxTrust };
declare class LuxTrust extends GenericCertCard implements AbstractLuxTrust {
    static ACTIVATED: string;
    activated(callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    rootCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    authenticationCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    signingCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
}

export { Ocra };
declare class Ocra extends GenericPinCard implements AbstractOcra {
    static CHALLENGE: string;
    static READ_COUNTER: string;
    challenge(body: ChallengeData, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    readCounter(body: OptionalPin, callback?: (error: RestException, data: ReadCounterResponse) => void): Promise<ReadCounterResponse>;
}

export { Aventra };
declare class Aventra extends GenericCertCard implements AbstractAventra {
    static DEFAULT_VERIFY_PIN: string;
    static RESET_PIN: string;
    allDataFilters(): string[];
    allCertFilters(): string[];
    allKeyRefs(): string[];
    rootCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    issuerCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    authenticationCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    signingCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    encryptionCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    verifyPin(body: VerifyPinData, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    resetPin(body: ResetPinData, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
}

export { Oberthur };
declare class Oberthur extends GenericCertCard implements AbstractOberthur {
    allDataFilters(): string[];
    allCertFilters(): string[];
    allKeyRefs(): string[];
    rootCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    issuerCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    authenticationCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    signingCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    encryptionCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    verifyPin(body: VerifyPinData, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
}

export { PIV };
declare class PIV extends GenericSecuredCertCard implements AbstractPiv {
    static PRINTED_INFORMATION: string;
    static FACIAL_IMAGE: string;
    allDataFilters(): string[];
    allCertFilters(): string[];
    allKeyRefs(): string[];
    printedInformation(body: OptionalPin, callback?: (error: RestException, data: PrintedInformationResponse) => void): Promise<PrintedInformationResponse>;
    facialImage(body: OptionalPin, callback?: (error: RestException, data: FacialImageResponse) => void): Promise<FacialImageResponse>;
    authenticationCertificate(body: OptionalPin, options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    signingCertificate(body: OptionalPin, options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
}

export { AbstractFileExchange, FileListResponse, ListFilesRequest, File };
interface AbstractFileExchange {
    listFiles(data: ListFilesRequest, callback?: (error: RestException, data: FileListResponse) => void): Promise<FileListResponse>;
    setFolder(callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    downloadFile(path: string, file: ArrayBuffer, fileName: string): Promise<DataResponse>;
    uploadFile(path: string): Promise<string>;
}
declare class ListFilesRequest {
    path: string;
    extensions: string[];
    constructor(path: string, extensions: string[]);
}
declare class File {
    extension: string;
    name: string;
    path: string;
    size: number;
    last_modification_time: string;
    constructor(extension: string, name: string, path: string, size: number, last_modification_time: string);
}
declare class FileListResponse extends T1CResponse {
    data: File[];
    success: boolean;
    constructor(data: File[], success: boolean);
}

export { AbstractDataContainer };
interface AbstractDataContainer {
    create(data: any, callback?: (error: RestException, data: any) => void): Promise<any>;
    read(id?: string, callback?: (error: RestException, data: any) => void): Promise<any>;
    update(id: string, data: any, callback?: (error: RestException, data: any) => void): Promise<any>;
    delete(id: string, callback?: (error: RestException, data: any) => void): Promise<any>;
}

export { AbstractAdmin, PubKeys, PubKeyResponse, SetPubKeyRequest, ContainerSyncRequest };
interface AbstractAdmin {
    activate(callback?: (error: CoreExceptions.RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    getPubKey(callback?: (error: CoreExceptions.RestException, data: PubKeyResponse) => void): Promise<PubKeyResponse>;
    setPubKey(keys: SetPubKeyRequest, callback?: (error: CoreExceptions.RestException, data: PubKeyResponse) => void): Promise<PubKeyResponse>;
    updateContainerConfig(containers: ContainerSyncRequest, callback?: (error: CoreExceptions.RestException, data: T1CResponse) => void): Promise<T1CResponse>;
}
class SetPubKeyRequest {
    encryptedPublicKey: string;
    encryptedAesKey: string;
    constructor(encryptedPublicKey: string, encryptedAesKey: string);
}
class PubKeyResponse implements T1CResponse {
    data: PubKeys;
    success: boolean;
    constructor(data: PubKeys, success: boolean);
}
class PubKeys {
    device: string;
    ssl: string;
    constructor(device: string, ssl: string);
}
class ContainerSyncRequest {
    containerResponses: DSContainer[];
    constructor(containerResponses: DSContainer[]);
}

