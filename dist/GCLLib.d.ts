// Generated by dts-bundle v0.7.3

class GCLClient {
    constructor(cfg: GCLConfig, automatic: boolean);
    static checkPolyfills(): void;
    static initialize(cfg: GCLConfig, callback?: (error: RestException, client: GCLClient) => void): Promise<GCLClient>;
    admin: () => AdminService;
    auth: () => AuthClient;
    core: () => CoreService;
    config: () => GCLConfig;
    agent: () => AbstractAgent;
    ds: () => DSClient;
    ocv: () => AbstractOCVClient;
    pf: () => PluginFactory;
    beid: (reader_id?: string) => AbstractEidBE;
    dnie: (reader_id?: string) => AbstractDNIe;
    luxeid: (reader_id?: string, pin?: string) => AbstractEidLUX;
    luxtrust: (reader_id?: string, pin?: string) => AbstractLuxTrust;
    emv: (reader_id?: string) => AbstractEMV;
    mobib: (reader_id?: string) => AbstractMobib;
    ocra: (reader_id?: string) => AbstractOcra;
    aventra: (reader_id?: string) => AbstractAventra;
    oberthur: (reader_id?: string) => AbstractOberthur;
    piv: (reader_id?: string) => AbstractPiv;
    pteid: (reader_id?: string) => AbstractEidPT;
    pkcs11: () => AbstractPkcs11;
    readerapi: (reader_id: string) => AbstractRemoteLoading;
    belfius: (reader_id: string) => AbstractBelfius;
    filex: () => AbstractFileExchange;
    gclInstalled: boolean;
    containerFor(readerId: string, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    download(callback?: (error: RestException, data: DSDownloadLinkResponse) => void): Promise<DSDownloadLinkResponse>;
    dumpData(readerId: string, data: OptionalPin, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    readersCanAuthenticate(callback?: (error: RestException, data: CardReadersResponse) => void): Promise<any>;
    authenticate(readerId: string, data: AuthenticateOrSignData, callback?: (error: RestException, data: DataResponse) => void): Promise<any>;
    readersCanSign(callback?: (error: RestException, data: CardReadersResponse) => void): Promise<any>;
    sign(readerId: string, data: AuthenticateOrSignData, callback?: (error: RestException, data: DataResponse) => void): Promise<any>;
    readersCanVerifyPin(callback?: (error: RestException, data: CardReadersResponse) => void): Promise<any>;
    verifyPin(readerId: string, data: OptionalPin, callback?: (error: RestException, data: DataResponse) => void): Promise<any>;
    updateAuthConnection(cfg: GCLConfig): void;
}
export { GCLClient, GCLConfig };

export class CoreService implements AbstractCore {
    constructor(url: string, connection: LocalAuthConnection);
    getConsent(title: string, codeWord: string, durationInDays?: number, alertLevel?: string, alertPosition?: string, type?: string, timeoutInSeconds?: number, callback?: (error: RestException, data: BoolDataResponse) => void): Promise<BoolDataResponse>;
    getImplicitConsent(codeWord: string, durationInDays?: number, type?: string, callback?: (error: RestException, data: BoolDataResponse) => void): Promise<BoolDataResponse>;
    info(callback?: (error: RestException, data: InfoResponse) => void): Promise<InfoResponse>;
    infoBrowser(callback?: (error: RestException, data: BrowserInfoResponse) => void): Promise<BrowserInfoResponse>;
    pollCardInserted(secondsToPollCard?: number, callback?: (error: RestException, data: CardReader) => void, connectReaderCb?: () => void, insertCardCb?: () => void, cardTimeoutCb?: () => void): Promise<CardReader>;
    pollReadersWithCards(secondsToPollCard?: number, callback?: (error: RestException, data: CardReadersResponse) => void, connectReaderCb?: () => void, insertCardCb?: () => void, cardTimeoutCb?: () => void): Promise<CardReadersResponse>;
    pollReaders(secondsToPollReader?: number, callback?: (error: RestException, data: CardReadersResponse) => void, connectReaderCb?: () => void, readerTimeoutCb?: () => void): Promise<CardReadersResponse>;
    reader(reader_id: string, callback?: (error: RestException, data: SingleReaderResponse) => void): Promise<SingleReaderResponse>;
    readers(callback?: (error: RestException, data: CardReadersResponse) => void): Promise<CardReadersResponse>;
    readersCardAvailable(callback?: (error: RestException, data: CardReadersResponse) => void): Promise<CardReadersResponse>;
    readersCardsUnavailable(callback?: (error: RestException, data: CardReadersResponse) => void): Promise<CardReadersResponse>;
    infoBrowserSync(): BrowserInfoResponse;
    getUrl(): string;
    version(): Promise<string>;
}

export interface AbstractDSClient {
    getUrl(): string;
    getInfo(callback?: (error: RestException, data: DSInfoResponse) => void): Promise<DSInfoResponse>;
    getDevice(uuid: string, callback?: (error: RestException, data: DeviceResponse) => void): Promise<DeviceResponse>;
    getPubKey(deviceId: string, callback?: (error: RestException, data: DSPubKeyResponse) => void): Promise<DSPubKeyResponse>;
    downloadLink(downloadData: DSDownloadRequest, callback?: (error: RestException, data: DSDownloadLinkResponse) => void): Promise<DSDownloadLinkResponse>;
    register(registrationData: DSRegistrationOrSyncRequest, callback?: (error: RestException, data: DeviceResponse) => void): Promise<DeviceResponse>;
    sync(syncData: DSRegistrationOrSyncRequest, callback?: (error: RestException, data: DeviceResponse) => void): Promise<DeviceResponse>;
}
export class DSBrowser {
    name: string;
    version: string;
    constructor(name: string, version: string);
}
export class DSOperatingSystem {
    architecture: number;
    name: string;
    version: string;
    constructor(architecture: number, name: string, version: string);
}
export class DSClientInfo {
    type: string;
    version: string;
    constructor(type: string, version: string);
}
export class DSDownloadRequest {
    browser: DSBrowser;
    manufacturer: string;
    os: DSOperatingSystem;
    ua: string;
    proxyDomain: string;
    constructor(browser: DSBrowser, manufacturer: string, os: DSOperatingSystem, ua: string, proxyDomain: string);
}
export class DSRegistrationOrSyncRequest {
    managed: boolean;
    activated: boolean;
    uuid: string;
    version: string;
    derEncodedPublicKey: string;
    manufacturer: string;
    browser: DSBrowser;
    os: DSOperatingSystem;
    ua: string;
    proxyDomain: string;
    clientInfo: DSClientInfo;
    containerStates: T1CContainer[];
    constructor(managed: boolean, activated: boolean, uuid: string, version: string, derEncodedPublicKey: string, manufacturer: string, browser: DSBrowser, os: DSOperatingSystem, ua: string, proxyDomain: string, clientInfo: DSClientInfo, containerStates?: T1CContainer[]);
}
export class DSInfoResponse {
    configFile: string;
    build: string;
    version: string;
    environemnt: string;
    storageAppName: string;
    storageServiceAccount: string;
    storageCertPath: string;
    storageBucket: string;
    storageDownloadPrefix: string;
    fileOsx: string;
    fileWin32: string;
    fileWin64: string;
    fileDefaultVersion: string;
    securityEnabled: string;
    securityPrivateKeyAvailable: boolean;
    constructor(configFile: string, build: string, version: string, environemnt: string, storageAppName: string, storageServiceAccount: string, storageCertPath: string, storageBucket: string, storageDownloadPrefix: string, fileOsx: string, fileWin32: string, fileWin64: string, fileDefaultVersion: string, securityEnabled: string, securityPrivateKeyAvailable: boolean);
}
export class DSDownloadLinkResponse {
    url: string;
    success: boolean;
    constructor(url: string, success: boolean);
}
export class DSJWTResponse {
    token: string;
    constructor(token: string);
}
export class DSPubKeyResponse {
    encryptedPublicKey: string;
    encryptedAesKey: string;
    success: boolean;
    constructor(encryptedPublicKey: string, encryptedAesKey: string, success: boolean);
}
export class DeviceResponse {
    uuid: string;
    activated: boolean;
    atrList: {
        hash: string;
        storagePath: string;
    };
    managed: boolean;
    coreVersion: string;
    contextToken: string;
    containerResponses: DSContainer[];
    constructor(uuid: string, activated: boolean, atrList: {
        hash: string;
        storagePath: string;
    }, managed: boolean, coreVersion: string, contextToken: string, containerResponses: DSContainer[]);
}
export class DSContainer {
    id: string;
    name: string;
    version: string;
    osStorage: DSStorage[];
    language: string;
    availability: string;
    dependsOn: string[];
    status: string;
    constructor(id: string, name: string, version: string, osStorage: DSStorage[], language: string, availability: string, dependsOn: string[], status: string);
}
export class DSStorage {
    hash: string;
    storagePath: string;
    os: string;
    constructor(hash: string, storagePath: string, os: string);
}
export class DSPlatformInfo extends BrowserInfo {
    activated: boolean;
    managed: boolean;
    bi: BrowserInfo;
    core_version: string;
    constructor(activated: boolean, managed: boolean, bi: BrowserInfo, core_version: string);
}

export class DSClient implements AbstractDSClient {
    constructor(url: string, connection: Connection, cfg: GCLConfig);
    getUrl(): string;
    getInfo(callback?: (error: RestException, data: DSInfoResponse) => void): Promise<DSInfoResponse>;
    getDevice(uuid: string, callback?: (error: RestException, data: DeviceResponse) => void): Promise<DeviceResponse>;
    getPubKey(uuid: string, callback?: (error: RestException, data: DSPubKeyResponse) => void): Promise<DSPubKeyResponse>;
    downloadLink(downloadData: DSDownloadRequest, callback?: (error: RestException, data: DSDownloadLinkResponse) => void): Promise<DSDownloadLinkResponse>;
    register(registrationData: DSRegistrationOrSyncRequest, callback?: (error: RestException, data: DeviceResponse) => void): Promise<DeviceResponse>;
    sync(syncData: DSRegistrationOrSyncRequest, callback?: (error: RestException, data: DeviceResponse) => void): Promise<DeviceResponse>;
}

export interface AbstractCore {
    getConsent(title: string, codeWord: string, durationInDays?: number, alertLevel?: string, alertPosition?: string, type?: string, timeoutInSeconds?: number, callback?: (error: RestException, data: BoolDataResponse) => void): Promise<BoolDataResponse>;
    getImplicitConsent(codeWord: string, durationInDays?: number, type?: string, callback?: (error: RestException, data: BoolDataResponse) => void): Promise<BoolDataResponse>;
    info(callback?: (error: RestException, data: InfoResponse) => void): void | Promise<InfoResponse>;
    infoBrowser(callback?: (error: RestException, data: BrowserInfoResponse) => void): Promise<BrowserInfoResponse>;
    pollCardInserted(secondsToPollCard?: number, callback?: (error: RestException, data: CardReader) => void, connectReader?: () => void, insertCard?: () => void, cardTimeout?: () => void): Promise<CardReader>;
    pollReadersWithCards(secondsToPollCard?: number, callback?: (error: RestException, data: CardReadersResponse) => void, connectReader?: () => void, insertCard?: () => void, cardTimeout?: () => void): Promise<CardReadersResponse>;
    pollReaders(secondsToPollReader?: number, callback?: (error: RestException, data: CardReadersResponse) => void, connectReader?: () => void, readerTimeout?: () => void): Promise<CardReadersResponse>;
    reader(reader_id: string, callback?: (error: RestException, data: SingleReaderResponse) => void): Promise<SingleReaderResponse>;
    readers(callback?: (error: RestException, data: CardReadersResponse) => void): Promise<CardReadersResponse>;
    readersCardAvailable(callback?: (error: RestException, data: CardReadersResponse) => void): Promise<CardReadersResponse>;
    readersCardsUnavailable(callback?: (error: RestException, data: CardReadersResponse) => void): Promise<CardReadersResponse>;
    getUrl(): string;
    infoBrowserSync(): BrowserInfoResponse;
    version(): Promise<string>;
}
export class T1CResponse {
    success: boolean;
    data: any;
    constructor(success: boolean, data: any);
}
export class BoolDataResponse extends T1CResponse {
    data: boolean;
    success: boolean;
    constructor(data: boolean, success: boolean);
}
export class DataResponse extends T1CResponse {
    data: string;
    success: boolean;
    constructor(data: string, success: boolean);
}
export class DataArrayResponse extends T1CResponse {
    data: any[];
    success: boolean;
    constructor(data: any[], success: boolean);
}
export class DataObjectResponse extends T1CResponse {
    data: {
        [key: string]: any;
    };
    success: boolean;
    constructor(data: {
        [key: string]: any;
    }, success: boolean);
}
export class InfoResponse extends T1CResponse {
    data: T1CInfo;
    success: boolean;
    constructor(data: T1CInfo, success: boolean);
}
export class T1CInfo {
    activated: boolean;
    citrix: boolean;
    managed: boolean;
    arch: string;
    os: string;
    uid: string;
    containers: T1CContainer[];
    version: string;
    constructor(activated: boolean, citrix: boolean, managed: boolean, arch: string, os: string, uid: string, containers: T1CContainer[], version: string);
}
export class T1CContainer {
    name: string;
    version: string;
    status: string;
    constructor(name: string, version: string, status: string);
}
export class BrowserInfoResponse extends T1CResponse {
    data: BrowserInfo;
    success: boolean;
    constructor(data: BrowserInfo, success: boolean);
}
export class BrowserInfo {
    browser: {
        name: string;
        version: string;
    };
    manufacturer: string;
    os: {
        name: string;
        version: string;
        architecture: number;
    };
    ua: string;
    constructor(browser: {
        name: string;
        version: string;
    }, manufacturer: string, os: {
        name: string;
        version: string;
        architecture: number;
    }, ua: string);
}
export class SmartCard {
    atr: string;
    description: string[];
    constructor(atr?: string, description?: string[]);
}
export class CardReader {
    id: string;
    name: string;
    pinpad: boolean;
    card: SmartCard;
    constructor(id: string, name: string, pinpad: boolean, card?: SmartCard);
}
export class CardReadersResponse extends T1CResponse {
    data: CardReader[];
    success: boolean;
    constructor(data: CardReader[], success: boolean);
}
export class CertificateResponse extends T1CResponse {
    data: T1CCertificate;
    success: boolean;
    constructor(data: T1CCertificate, success: boolean);
}
export class CertificatesResponse extends T1CResponse {
    data: T1CCertificate[];
    success: boolean;
    constructor(data: T1CCertificate[], success: boolean);
}
export class T1CCertificate {
    base64: string;
    id: string;
    parsed: object;
    constructor(base64: string, id?: string, parsed?: object);
}
export class SingleReaderResponse extends T1CResponse {
    data: CardReader;
    success: boolean;
    constructor(data: CardReader, success: boolean);
}

export interface AbstractEidBE extends CertCard {
    allData(filters: string[] | Options, callback?: (error: RestException, data: BeidAllDataResponse) => void): Promise<BeidAllDataResponse>;
    allCerts(filters: string[] | Options, callback?: (error: RestException, data: BeidAllCertsResponse) => void): Promise<BeidAllCertsResponse>;
    rnData(callback?: (error: RestException, data: BeidRnDataResponse) => void): Promise<BeidRnDataResponse>;
    tokenData(callback?: (error: RestException, data: BeidTokenDataResponse) => void): Promise<BeidTokenDataResponse>;
    address(callback?: (error: RestException, data: BeidAddressResponse) => void): Promise<BeidAddressResponse>;
    picture(callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    rootCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    citizenCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    authenticationCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    nonRepudiationCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    rrnCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    verifyPin(body: OptionalPin, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    tokenData(callback?: (error: RestException, data: BeidTokenDataResponse) => void): Promise<BeidTokenDataResponse>;
}
export declare class BeidAddressResponse extends DataObjectResponse {
    data: BeidAddress;
    success: boolean;
    constructor(data: BeidAddress, success: boolean);
}
export declare class BeidAddress {
    municipality: string;
    raw_data: string;
    signature: string;
    street_and_number: string;
    version: number;
    zipcode: string;
    constructor(municipality: string, raw_data: string, signature: string, street_and_number: string, version: number, zipcode: string);
}
export declare class BeidAllCertsResponse extends DataObjectResponse {
    data: BeidAllCerts;
    success: boolean;
    constructor(data: BeidAllCerts, success: boolean);
}
export declare class BeidAllCerts {
    authentication_certificate: T1CCertificate;
    citizen_certificate: T1CCertificate;
    non_repudiation_certificate: T1CCertificate;
    root_certificate: T1CCertificate;
    rrn_certificate: T1CCertificate;
    constructor(authentication_certificate?: T1CCertificate, citizen_certificate?: T1CCertificate, non_repudiation_certificate?: T1CCertificate, root_certificate?: T1CCertificate, rrn_certificate?: T1CCertificate);
}
export declare class BeidAllDataResponse extends BeidAllCertsResponse {
    data: BeidAllData;
    success: boolean;
    constructor(data: BeidAllData, success: boolean);
}
export declare class BeidAllData {
    address: BeidAddress;
    authentication_certificate: T1CCertificate;
    citizen_certificate: T1CCertificate;
    non_repudiation_certificate: T1CCertificate;
    picture: string;
    rn: BeidRnData;
    root_certificate: T1CCertificate;
    rrn_certificate: T1CCertificate;
    token_data: BeidTokenData;
    constructor(address?: BeidAddress, authentication_certificate?: T1CCertificate, citizen_certificate?: T1CCertificate, non_repudiation_certificate?: T1CCertificate, picture?: string, rn?: BeidRnData, root_certificate?: T1CCertificate, rrn_certificate?: T1CCertificate, token_data?: BeidTokenData);
}
export declare class BeidTokenData {
    eid_compliant: number;
    electrical_perso_interface_version: number;
    electrical_perso_version: number;
    graphical_perso_version: number;
    label: string;
    prn_generation: string;
    raw_data: string;
    serial_number: string;
    version: number;
    version_rfu: number;
    constructor(eid_compliant?: number, electrical_perso_interface_version?: number, electrical_perso_version?: number, graphical_perso_version?: number, label?: string, prn_generation?: string, raw_data?: string, serial_number?: string, version?: number, version_rfu?: number);
}
export declare class BeidTokenDataResponse extends DataObjectResponse {
    data: BeidTokenData;
    success: boolean;
    constructor(data: BeidTokenData, success: boolean);
}
export declare class BeidRnData {
    birth_date: string;
    birth_location: string;
    card_delivery_municipality: string;
    card_number: string;
    card_validity_date_begin: string;
    card_validity_date_end: string;
    chip_number: string;
    document_type: string;
    first_names: string;
    name: string;
    national_number: string;
    nationality: string;
    noble_condition: string;
    picture_hash: string;
    raw_data: string;
    sex: string;
    signature: string;
    special_status: string;
    third_name: string;
    version: number;
    constructor(birth_date: string, birth_location: string, card_delivery_municipality: string, card_number: string, card_validity_date_begin: string, card_validity_date_end: string, chip_number: string, document_type: string, first_names: string, name: string, national_number: string, nationality: string, noble_condition: string, picture_hash: string, raw_data: string, sex: string, signature: string, special_status: string, third_name: string, version: number);
}
export declare class BeidRnDataResponse extends DataObjectResponse {
    data: BeidRnData;
    success: boolean;
    constructor(data: BeidRnData, success: boolean);
}

export interface AbstractEMV extends PinCard {
    allData(filters: string[], callback?: (error: RestException, data: EmvAllDataResponse) => void): Promise<EmvAllDataResponse>;
    applications(callback?: (error: RestException, data: EmvApplicationsResponse) => void): Promise<EmvApplicationsResponse>;
    applicationData(callback?: (error: RestException, data: EmvApplicationDataResponse) => void): Promise<EmvApplicationDataResponse>;
    iccPublicKeyCertificate(aid: string, callback?: (error: RestException, data: EmvCertificateResponse) => void): Promise<EmvCertificateResponse>;
    issuerPublicKeyCertificate(aid: string, callback?: (error: RestException, data: EmvCertificateResponse) => void): Promise<EmvCertificateResponse>;
}
export declare class EmvAllDataResponse extends DataObjectResponse {
    data: {
        applications?: EmvApplication[];
        application_data?: EmvApplicationData;
    };
    success: boolean;
    constructor(data: {
        applications?: EmvApplication[];
        application_data?: EmvApplicationData;
    }, success: boolean);
}
export declare class EmvApplication {
    aid: string;
    name: string;
    priority: number;
    constructor(aid: string, name: string, priority: number);
}
export declare class EmvApplicationsResponse extends DataObjectResponse {
    data: EmvApplication[];
    success: boolean;
    constructor(data: EmvApplication[], success: boolean);
}
export declare class EmvApplicationData {
    country: string;
    country_code: string;
    effective_data: string;
    expiration_date: string;
    language: string;
    pan: string;
    name: string;
    constructor(country?: string, country_code?: string, effective_data?: string, expiration_date?: string, language?: string, pan?: string, name?: string);
}
export declare class EmvApplicationDataResponse extends DataObjectResponse {
    data: EmvApplicationData;
    success: boolean;
    constructor(data: EmvApplicationData, success: boolean);
}
export declare class EmvCertificate {
    data: string;
    exponent: string;
    remainder: string;
    constructor(data: string, exponent: string, remainder: string);
}
export declare class EmvCertificateResponse extends DataObjectResponse {
    data: EmvCertificate;
    success: boolean;
    constructor(data: EmvCertificate, success: boolean);
}

export interface AbstractOcra extends PinCard {
    allData(filters: string[], callback?: (error: RestException, data: OcraAllDataResponse) => void): Promise<OcraAllDataResponse>;
    challenge(body: OcraChallenge, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    readCounter(body: OptionalPin, callback?: (error: RestException, data: OcraReadCounterResponse) => void): Promise<OcraReadCounterResponse>;
}
export declare class OcraAllDataResponse extends DataObjectResponse {
    data: OcraAllData;
    success: boolean;
    constructor(data: OcraAllData, success: boolean);
}
export declare class OcraAllData {
    counter: string;
    constructor(counter?: string);
}
export declare class OcraChallenge extends OptionalPin {
    challenge: string;
    pin: string;
    pace: string;
    constructor(challenge: string, pin?: string, pace?: string);
}
export declare class OcraReadCounterResponse {
    counter: string;
    success: boolean;
    constructor(counter?: string, success?: boolean);
}

export interface AbstractAventra extends CertCard {
    allDataFilters(): string[];
    allCertFilters(): string[];
    allKeyRefs(): string[];
    allAlgoRefsForAuthentication(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    allAlgoRefsForSigning(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    allData(filters: string[], callback?: (error: RestException, data: AventraAllDataResponse) => void): Promise<AventraAllDataResponse>;
    allCerts(filters: string[], callback?: (error: RestException, data: AventraAllCertsResponse) => void): Promise<AventraAllCertsResponse>;
    rootCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    issuerCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    authenticationCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    signingCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    encryptionCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    verifyPin(body: VerifyPinData, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    resetPin(body: ResetPinData, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
}
export declare class AventraAllCertsResponse extends DataObjectResponse {
    data: AventraAllCerts;
    success: boolean;
    constructor(data: AventraAllCerts, success: boolean);
}
export declare class AventraAllCerts {
    authentication_certificate: T1CCertificate;
    encryption_certificate: T1CCertificate;
    issuer_certificate: T1CCertificate;
    signing_certificate: T1CCertificate;
    root_certificate: T1CCertificate;
    constructor(authentication_certificate?: T1CCertificate, encryption_certificate?: T1CCertificate, issuer_certificate?: T1CCertificate, signing_certificate?: T1CCertificate, root_certificate?: T1CCertificate);
}
export declare class AventraAllDataResponse extends DataObjectResponse {
    data: AventraAllData;
    success: boolean;
    constructor(data: AventraAllData, success: boolean);
}
export declare class AventraAllData {
    applet_info: AventraAppletInfo;
    authentication_certificate: T1CCertificate;
    encryption_certificate: T1CCertificate;
    issuer_certificate: T1CCertificate;
    signing_certificate: T1CCertificate;
    root_certificate: T1CCertificate;
    constructor(applet_info?: AventraAppletInfo, authentication_certificate?: T1CCertificate, encryption_certificate?: T1CCertificate, issuer_certificate?: T1CCertificate, signing_certificate?: T1CCertificate, root_certificate?: T1CCertificate);
}
export declare class AventraAppletInfo {
    change_counter: number;
    name: string;
    serial: string;
    version: string;
    constructor(change_counter?: number, name?: string, serial?: string, version?: string);
}

export interface AbstractLuxTrust extends CertCard {
    activated(callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    allData(filters: string[], callback?: (error: RestException, data: LuxtrustAllDataResponse) => void): Promise<LuxtrustAllDataResponse>;
    allCerts(filters: string[], callback?: (error: RestException, data: LuxtrustAllCertsResponse) => void): Promise<LuxtrustAllCertsResponse>;
    rootCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    authenticationCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    signingCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
}
export declare class LuxtrustAllCertsResponse extends DataObjectResponse {
    data: LuxtrustAllCerts;
    success: boolean;
    constructor(data: LuxtrustAllCerts, success: boolean);
}
export declare class LuxtrustAllCerts {
    authentication_certificate: T1CCertificate;
    non_repudiation_certificate: T1CCertificate;
    root_certificate: T1CCertificate[];
    constructor(authentication_certificate?: T1CCertificate, non_repudiation_certificate?: T1CCertificate, root_certificate?: T1CCertificate[]);
}
export declare class LuxtrustAllDataResponse extends LuxtrustAllCertsResponse {
    data: LuxtrustAllCerts;
    success: boolean;
    constructor(data: LuxtrustAllCerts, success: boolean);
}

export interface AbstractOberthur extends CertCard {
    allDataFilters(): string[];
    allCertFilters(): string[];
    allKeyRefs(): string[];
    allAlgoRefsForAuthentication(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    allAlgoRefsForSigning(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    allData(filters: string[], callback?: (error: RestException, data: OberthurAllDataResponse) => void): Promise<OberthurAllDataResponse>;
    allCerts(filters: string[], callback?: (error: RestException, data: OberthurAllCertsResponse) => void): Promise<OberthurAllCertsResponse>;
    rootCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    issuerCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    authenticationCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    signingCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    encryptionCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
}
export declare class OberthurAllCertsResponse extends DataObjectResponse {
    data: OberthurAllCerts;
    success: boolean;
    constructor(data: OberthurAllCerts, success: boolean);
}
export declare class OberthurAllCerts {
    root_certificate: T1CCertificate;
    issuer_certificate: T1CCertificate;
    authentication_certificate: T1CCertificate;
    signing_certificate: T1CCertificate;
    encryption_certificate: T1CCertificate;
    constructor(root_certificate?: T1CCertificate, issuer_certificate?: T1CCertificate, authentication_certificate?: T1CCertificate, signing_certificate?: T1CCertificate, encryption_certificate?: T1CCertificate);
}
export declare class OberthurAllDataResponse extends OberthurAllCertsResponse {
    data: OberthurAllCerts;
    success: boolean;
    constructor(data: OberthurAllCerts, success: boolean);
}

export interface AbstractPiv extends SecuredCertCard {
    allDataFilters(): string[];
    allCertFilters(): string[];
    allKeyRefs(): string[];
    printedInformation(body: OptionalPin, callback?: (error: RestException, data: PivPrintedInformationResponse) => void): Promise<PivPrintedInformationResponse>;
    facialImage(body: OptionalPin, callback?: (error: RestException, data: PivFacialImageResponse) => void): Promise<PivFacialImageResponse>;
    allData(filters: string[], body: OptionalPin, callback?: (error: RestException, data: PivAllDataResponse) => void): Promise<PivAllDataResponse>;
    allCerts(filters: string[], body: OptionalPin, callback?: (error: RestException, data: PivAllCertsResponse) => void): Promise<PivAllCertsResponse>;
    authenticationCertificate(body: OptionalPin, options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    signingCertificate(body: OptionalPin, options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
}
export declare class PivPrintedInformationResponse extends DataObjectResponse {
    data: PivPrintedInformation;
    success: boolean;
    constructor(data: PivPrintedInformation, success: boolean);
}
export declare class PivAllCertsResponse extends DataObjectResponse {
    data: PivAllCerts;
    success: boolean;
    constructor(data: PivAllCerts, success: boolean);
}
export declare class PivPrintedInformation {
    name: string;
    employee_affiliation: string;
    expiration_date: string;
    agency_card_serial_number: any;
    issuer_identification: string;
    organization_affiliation_line_1: string;
    organization_affiliation_line_2: string;
    constructor(name: string, employee_affiliation: string, expiration_date: string, agency_card_serial_number: any, issuer_identification: string, organization_affiliation_line_1: string, organization_affiliation_line_2: string);
}
export declare class PivFacialImageResponse extends DataObjectResponse {
    data: PivFacialImage;
    success: boolean;
    constructor(data: PivFacialImage, success: boolean);
}
export declare class PivFacialImage {
    image: string;
    constructor(image: string);
}
export declare class PivAllCerts {
    authentication_certificate: T1CCertificate;
    signing_certificate: T1CCertificate;
    constructor(authentication_certificate?: T1CCertificate, signing_certificate?: T1CCertificate);
}
export declare class PivAllDataResponse extends DataObjectResponse {
    data: PivAllData;
    success: boolean;
    constructor(data: PivAllData, success: boolean);
}
export declare class PivAllData {
    printed_information: PivPrintedInformation;
    authentication_certificate: T1CCertificate;
    signing_certificate: T1CCertificate;
    facial_image: PivFacialImage;
    constructor(printed_information?: PivPrintedInformation, authentication_certificate?: T1CCertificate, signing_certificate?: T1CCertificate, facial_image?: PivFacialImage);
}

export interface AbstractMobib extends Card {
    allData(filters: string[] | Options, callback?: (error: RestException, data: MobibAllDataResponse) => void): Promise<MobibAllDataResponse>;
    cardIssuing(callback?: (error: RestException, data: MobibCardIssuingResponse) => void): Promise<MobibCardIssuingResponse>;
    contracts(callback?: (error: RestException, data: MobibContractsResponse) => void): Promise<MobibContractsResponse>;
    picture(callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    status(callback?: (error: RestException, data: MobibStatusResponse) => void): Promise<MobibStatusResponse>;
}
export declare class MobibAllDataResponse extends DataObjectResponse {
    data: {
        active?: boolean;
        'card-issuing'?: MobibCardIssuing;
        contracts?: MobibContract[];
        picture?: string;
    };
    success: boolean;
    constructor(data: {
        active?: boolean;
        'card-issuing'?: MobibCardIssuing;
        contracts?: MobibContract[];
        picture?: string;
    }, success: boolean);
}
export declare class MobibStatusResponse extends DataObjectResponse {
    data: {
        active: boolean;
    };
    success: boolean;
    constructor(data: {
        active: boolean;
    }, success: boolean);
}
export declare class MobibCardIssuing {
    card_expiration_date: string;
    card_holder_birth_date: string;
    card_holder_end_date: string;
    card_holder_id: string;
    card_holder_name: string;
    card_holder_start_date: string;
    card_revalidation_date: string;
    card_type: number;
    company_id: number;
    gender: number;
    language: number;
    version: number;
    constructor(card_expiration_date?: string, card_holder_birth_date?: string, card_holder_end_date?: string, card_holder_id?: string, card_holder_name?: string, card_holder_start_date?: string, card_revalidation_date?: string, card_type?: number, company_id?: number, gender?: number, language?: number, version?: number);
}
export declare class MobibCardIssuingResponse extends DataObjectResponse {
    data: MobibCardIssuing;
    success: boolean;
    constructor(data: MobibCardIssuing, success: boolean);
}
export declare class MobibContract {
    authenticator_kvc: number;
    authenticator_value: number;
    journey_interchanges_allowed: boolean;
    passengers_max: number;
    period_journeys: {
        max_number_of_trips?: number;
        period?: number;
    };
    price_amount: number;
    provider: number;
    restrict_code: number;
    restrict_time: number;
    sale_date: string;
    sale_sam_count: number;
    sale_sam_id: number;
    spatials: {
        type: number;
    }[];
    tariff: {
        counter: {
            time?: string;
            type?: number;
        };
        multimodal?: boolean;
        nameref?: number;
    };
    validity_duration: {
        unit?: number;
        value?: number;
    };
    validity_start_date: string;
    vehicle_class_allowed: number;
    version: number;
    constructor(authenticator_kvc?: number, authenticator_value?: number, journey_interchanges_allowed?: boolean, passengers_max?: number, period_journeys?: {
        max_number_of_trips?: number;
        period?: number;
    }, price_amount?: number, provider?: number, restrict_code?: number, restrict_time?: number, sale_date?: string, sale_sam_count?: number, sale_sam_id?: number, spatials?: {
        type: number;
    }[], tariff?: {
        counter: {
            time?: string;
            type?: number;
        };
        multimodal?: boolean;
        nameref?: number;
    }, validity_duration?: {
        unit?: number;
        value?: number;
    }, validity_start_date?: string, vehicle_class_allowed?: number, version?: number);
}
export declare class MobibContractsResponse extends DataArrayResponse {
    data: MobibContract[];
    success: boolean;
    constructor(data: MobibContract[], success: boolean);
}

export interface AbstractEidLUX extends CertCard {
    allDataFilters(): string[];
    allCertFilters(): string[];
    allData(options?: string[] | Options, callback?: (error: RestException, data: LuxAllDataResponse) => void): Promise<LuxAllDataResponse>;
    allCerts(options?: string[] | Options, callback?: (error: RestException, data: AllCertsResponse) => void): Promise<AllCertsResponse>;
    biometric(callback?: (error: RestException, data: LuxidBiometricResponse) => void): Promise<LuxidBiometricResponse>;
    picture(callback?: (error: RestException, data: LuxidPictureResponse) => void): Promise<LuxidPictureResponse>;
    rootCertificate(options?: Options, callback?: (error: RestException, data: CertificatesResponse) => void): Promise<CertificatesResponse>;
    authenticationCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    nonRepudiationCertificate(options?: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    signatureImage(callback?: (error: RestException, data: LuxidSignatureImageResponse) => void): Promise<LuxidSignatureImageResponse>;
}
export declare class AllCertsResponse extends DataObjectResponse {
    data: LuxidAllCerts;
    success: boolean;
    constructor(data: LuxidAllCerts, success: boolean);
}
export declare class LuxidAllCerts {
    authentication_certificate: T1CCertificate;
    non_repudiation_certificate: T1CCertificate;
    root_certificates: T1CCertificate[];
    constructor(authentication_certificate?: T1CCertificate, non_repudiation_certificate?: T1CCertificate, root_certificates?: T1CCertificate[]);
}
export declare class LuxAllDataResponse extends AllCertsResponse {
    data: LuxidAllData;
    success: boolean;
    constructor(data: LuxidAllData, success: boolean);
}
export declare class LuxidAllData extends LuxidAllCerts {
    authentication_certificate: T1CCertificate;
    non_repudiation_certificate: T1CCertificate;
    root_certificates: T1CCertificate[];
    biometric: LuxidBiometric;
    picture: LuxidPicture;
    signature_image: LuxidSignatureImage;
    signature_object: string;
    constructor(authentication_certificate?: T1CCertificate, non_repudiation_certificate?: T1CCertificate, root_certificates?: T1CCertificate[], biometric?: LuxidBiometric, picture?: LuxidPicture, signature_image?: LuxidSignatureImage, signature_object?: string);
}
export declare class LuxidBiometric {
    birthData: string;
    documentNumber: string;
    documentType: string;
    firstName: string;
    gender: string;
    issuingState: string;
    lastName: string;
    nationality: string;
    validityEndData: string;
    validityStartData: string;
    constructor(birthData?: string, documentNumber?: string, documentType?: string, firstName?: string, gender?: string, issuingState?: string, lastName?: string, nationality?: string, validityEndData?: string, validityStartData?: string);
}
export declare class LuxidBiometricResponse extends DataObjectResponse {
    data: LuxidBiometric;
    success: boolean;
    constructor(data: LuxidBiometric, success: boolean);
}
export declare class LuxidPicture {
    height: number;
    width: number;
    image: string;
    raw_data: string;
    constructor(height: number, width: number, image: string, raw_data: string);
}
export declare class LuxidPictureResponse extends DataObjectResponse {
    data: LuxidPicture;
    success: boolean;
    constructor(data: LuxidPicture, success: boolean);
}
export declare class LuxidSignatureImage {
    image: string;
    raw_data: string;
    constructor(image: string, raw_data: string);
}
export declare class LuxidSignatureImageResponse extends DataObjectResponse {
    data: LuxidSignatureImage;
    success: boolean;
    constructor(data: LuxidSignatureImage, success: boolean);
}

export interface AbstractDNIe extends SecuredCertCard {
    allData(filters: string[] | Options, body: OptionalPin, callback?: (error: RestException, data: DNIeAllDataResponse) => void): Promise<DNIeAllDataResponse>;
    allCerts(options: Options, body: OptionalPin, callback?: (error: RestException, data: DNIeAllCertsResponse) => void): Promise<DNIeAllCertsResponse>;
    info(callback?: (error: RestException, data: DNIeInfoResponse) => void): Promise<DNIeInfoResponse>;
    intermediateCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    authenticationCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    signingCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
}
export declare class DNIeAllCertsResponse extends DataObjectResponse {
    data: DNIeAllCerts;
    success: boolean;
    constructor(data: DNIeAllCerts, success: boolean);
}
export declare class DNIeAllCerts {
    authentication_certificate: T1CCertificate;
    intermediate_certificate: T1CCertificate;
    signing_certificate: T1CCertificate;
    constructor(authentication_certificate?: T1CCertificate, intermediate_certificate?: T1CCertificate, signing_certificate?: T1CCertificate);
}
export declare class DNIeAllDataResponse extends DNIeAllCertsResponse {
    data: DNIeAllData;
    success: boolean;
    constructor(data: DNIeAllData, success: boolean);
}
export declare class DNIeAllData {
    info: DNIeInfo;
    authentication_certificate: T1CCertificate;
    intermediate_certificate: T1CCertificate;
    signing_certificate: T1CCertificate;
    constructor(info?: DNIeInfo, authentication_certificate?: T1CCertificate, intermediate_certificate?: T1CCertificate, signing_certificate?: T1CCertificate);
}
export declare class DNIeInfoResponse extends DataObjectResponse {
    data: DNIeInfo;
    success: boolean;
    constructor(data: DNIeInfo, success: boolean);
}
export declare class DNIeInfo {
    first_name: string;
    last_names: string;
    national_number: string;
    card_number: string;
    serial: string;
    constructor(first_name: string, last_names: string, national_number: string, card_number: string, serial: string);
}

export interface AbstractFactory {
    createEidBE(reader_id?: string): AbstractEidBE;
    createEidLUX(reader_id?: string): AbstractEidLUX;
    createEmv(reader_id?: string): AbstractEMV;
    createLuxTrust(reader_id?: string): AbstractLuxTrust;
    createMobib(reader_id?: string): AbstractMobib;
    createOcra(reader_id?: string): AbstractOcra;
    createAventraNO(reader_id?: string): AbstractAventra;
    createOberthurNO(reader_id?: string): AbstractOberthur;
    createPIV(reader_id?: string): AbstractPiv;
    createPKCS11(): AbstractPkcs11;
}
export declare class PluginFactory implements AbstractFactory {
    constructor(url: string, connection: LocalConnection);
    createDNIe(reader_id?: string): AbstractDNIe;
    createEidBE(reader_id?: string): AbstractEidBE;
    createEidLUX(reader_id?: string, pin?: string): AbstractEidLUX;
    createEidPT(reader_id?: string): AbstractEidPT;
    createEmv(reader_id?: string): AbstractEMV;
    createLuxTrust(reader_id?: string): AbstractLuxTrust;
    createMobib(reader_id?: string): AbstractMobib;
    createOcra(reader_id?: string): AbstractOcra;
    createAventraNO(reader_id?: string): AbstractAventra;
    createOberthurNO(reader_id?: string): AbstractOberthur;
    createPIV(reader_id?: string): AbstractPiv;
    createPKCS11(): AbstractPkcs11;
    createRemoteLoading(reader_id?: string): AbstractRemoteLoading;
    createBelfius(reader_id?: string): AbstractBelfius;
    createFileExchange(): AbstractFileExchange;
    createDataContainer(containerPath: string): () => AbstractDataContainer;
}

export interface Card {
    allData: (filters: string[] | Options, callback?: () => void) => Promise<DataObjectResponse>;
}
export interface PinCard extends Card {
    verifyPin: (body: VerifyPinData, callback?: () => void) => Promise<T1CResponse>;
}
export interface CertCard extends PinCard {
    allCerts: (filters: string[] | Options, callback?: () => void) => Promise<DataObjectResponse>;
    authenticate: (body: any, callback?: () => void) => Promise<DataResponse>;
    signData: (body: any, callback?: () => void) => Promise<DataResponse>;
}
export interface SecuredCertCard {
    allCerts: (filters: string[] | Options, body: OptionalPin, callback?: () => void) => Promise<DataObjectResponse>;
    allData: (filters: string[] | Options, body: OptionalPin, callback?: () => void) => Promise<DataObjectResponse>;
    authenticate: (body: any, callback?: () => void) => Promise<DataResponse>;
    signData: (body: any, callback?: () => void) => Promise<DataResponse>;
    verifyPin: (body: OptionalPin, callback?: () => void) => Promise<T1CResponse>;
}
export declare class OptionalPin {
    pin: string;
    pace: string;
    constructor(pin?: string, pace?: string);
}
export declare class AuthenticateOrSignData extends OptionalPin {
    algorithm_reference: string;
    data: string;
    pin: string;
    pace: string;
    constructor(algorithm_reference: string, data: string, pin?: string, pace?: string);
}
export declare class VerifyPinData extends OptionalPin {
    private_key_reference: string;
    pin: string;
    pace: string;
    constructor(private_key_reference?: string, pin?: string, pace?: string);
}
export declare class ResetPinData {
    puk: string;
    new_pin: string;
    private_key_reference: string;
    constructor(puk: string, new_pin: string, private_key_reference: string);
}
export declare abstract class GenericContainer {
    protected baseUrl: string;
    protected containerUrl: string;
    protected connection: LocalConnection;
    constructor(baseUrl: string, containerUrl: string, connection: LocalConnection);
    protected containerSuffix(path?: string): string;
}
export declare abstract class GenericReaderContainer extends GenericContainer {
    protected baseUrl: string;
    protected containerUrl: string;
    protected connection: LocalConnection;
    protected reader_id: string;
    constructor(baseUrl: string, containerUrl: string, connection: LocalConnection, reader_id: string);
    protected containerSuffix(path?: string): string;
}
export declare abstract class GenericSmartCard extends GenericReaderContainer implements Card {
    allData(options: string[] | Options, callback?: (error: RestException, data: DataObjectResponse) => void): Promise<DataObjectResponse>;
}
export declare abstract class GenericPinCard extends GenericSmartCard implements PinCard {
    static VERIFY_PIN: string;
    verifyPin(body: VerifyPinData, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
}
export declare abstract class GenericCertCard extends GenericPinCard implements CertCard {
    static ALL_CERTIFICATES: string;
    static AUTHENTICATE: string;
    static CERT_ROOT: string;
    static CERT_AUTHENTICATION: string;
    static CERT_NON_REPUDIATION: string;
    static CERT_ISSUER: string;
    static CERT_SIGNING: string;
    static CERT_ENCRYPTION: string;
    static CERT_CITIZEN: string;
    static CERT_RRN: string;
    static SIGN_DATA: string;
    allAlgoRefsForAuthentication(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    allAlgoRefsForSigning(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    allCerts(options: string[] | Options, callback?: (error: RestException, data: DataObjectResponse) => void): Promise<DataObjectResponse>;
    authenticate(body: AuthenticateOrSignData, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    signData(body: AuthenticateOrSignData, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    protected getCertificate(certUrl: string, options: RequestOptions): Promise<CertificateResponse>;
}
export declare abstract class GenericSecuredCertCard extends GenericReaderContainer implements SecuredCertCard {
    static ALL_CERTIFICATES: string;
    static AUTHENTICATE: string;
    static CERT_AUTHENTICATION: string;
    static CERT_NON_REPUDIATION: string;
    static CERT_INTERMEDIATE: string;
    static CERT_ROOT: string;
    static CERT_SIGNING: string;
    static SIGN_DATA: string;
    static VERIFY_PIN: string;
    allAlgoRefsForAuthentication(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    allAlgoRefsForSigning(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    allData(options: string[] | Options, body: OptionalPin, callback?: (error: RestException, data: DataObjectResponse) => void): Promise<DataObjectResponse>;
    allCerts(options: string[] | Options, body: OptionalPin, callback?: (error: RestException, data: DataObjectResponse) => void): Promise<DataObjectResponse>;
    verifyPin(body: OptionalPin, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    signData(body: AuthenticateOrSignData, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    authenticate(body: AuthenticateOrSignData, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    protected getCertificate(certUrl: string, body: OptionalPin, options: RequestOptions, params?: {
        filter?: string;
        pin?: string;
    }): Promise<CertificateResponse>;
    protected getCertificateArray(certUrl: string, body: OptionalPin, options: RequestOptions, params?: {
        filter?: string;
        pin?: string;
    }): Promise<CertificatesResponse>;
}

export class RestException {
    status: number;
    code: string;
    description: string;
    client: GCLClient;
    constructor(status: number, code: string, description: string, client?: GCLClient);
}

export interface AbstractEidPT extends CertCard {
    allData(filters: string[], callback?: (error: RestException, data: PtAllDataResponse) => void): Promise<PtAllDataResponse>;
    allCerts(filters: string[], callback?: (error: RestException, data: PtAllCertsResponse) => void): Promise<PtAllCertsResponse>;
    idData(callback?: (error: RestException, data: PtIdDataResponse) => void): Promise<PtIdDataResponse>;
    idDataWithOutPhoto(callback?: (error: RestException, data: PtIdDataResponse) => void): Promise<PtIdDataResponse>;
    address(data: OptionalPin, callback?: (error: RestException, data: PtAddressResponse) => void): Promise<PtAddressResponse>;
    photo(callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    rootCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    rootAuthenticationCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    rootNonRepudiationCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    authenticationCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
    nonRepudiationCertificate(options: Options, callback?: (error: RestException, data: CertificateResponse) => void): Promise<CertificateResponse>;
}
export declare class PtAllCertsResponse extends DataObjectResponse {
    data: PtAllCerts;
    success: boolean;
    constructor(data: PtAllCerts, success: boolean);
}
export declare class PtAllCerts {
    authentication_certificate: T1CCertificate;
    non_repudiation_certificate: T1CCertificate;
    root_authentication_certificate: T1CCertificate;
    root_certificate: T1CCertificate;
    root_non_repudiation_certificate: T1CCertificate;
    constructor(authentication_certificate?: T1CCertificate, non_repudiation_certificate?: T1CCertificate, root_authentication_certificate?: T1CCertificate, root_certificate?: T1CCertificate, root_non_repudiation_certificate?: T1CCertificate);
}
export declare class PtAllDataResponse extends DataObjectResponse {
    data: PtAllData;
    success: boolean;
    constructor(data: PtAllData, success: boolean);
}
export declare class PtAllData {
    id: PtIdData;
    authentication_certificate: T1CCertificate;
    non_repudiation_certificate: T1CCertificate;
    root_authentication_certificate: T1CCertificate;
    root_certificate: T1CCertificate;
    root_non_repudiaton_certificate: T1CCertificate;
    constructor(id?: PtIdData, authentication_certificate?: T1CCertificate, non_repudiation_certificate?: T1CCertificate, root_authentication_certificate?: T1CCertificate, root_certificate?: T1CCertificate, root_non_repudiaton_certificate?: T1CCertificate);
}
export declare class PtIdData {
    accidental_indications: boolean;
    civilian_number: string;
    country: string;
    date_of_birth: string;
    document_number: string;
    document_number_pan: string;
    document_type: string;
    document_version: string;
    gender: string;
    given_name_father: string;
    given_name_mother: string;
    health_no: string;
    height: string;
    issuing_entity: string;
    local_of_request: string;
    mrz1: string;
    mrz2: string;
    mrz3: string;
    name: string;
    nationality: string;
    raw_data: string;
    social_security_no: string;
    surname: string;
    surname_father: string;
    surname_mother: string;
    tax_no: string;
    validity_begin_date: string;
    validity_end_date: string;
    photo: string;
    constructor(accidental_indications?: boolean, civilian_number?: string, country?: string, date_of_birth?: string, document_number?: string, document_number_pan?: string, document_type?: string, document_version?: string, gender?: string, given_name_father?: string, given_name_mother?: string, health_no?: string, height?: string, issuing_entity?: string, local_of_request?: string, mrz1?: string, mrz2?: string, mrz3?: string, name?: string, nationality?: string, raw_data?: string, social_security_no?: string, surname?: string, surname_father?: string, surname_mother?: string, tax_no?: string, validity_begin_date?: string, validity_end_date?: string, photo?: string);
}
export declare class PtIdDataResponse extends DataObjectResponse {
    data: PtIdData;
    success: boolean;
    constructor(data: PtIdData, success: boolean);
}
export declare class PtAddressData {
    abbr_building_type: string;
    abbr_street_type: string;
    building_type: string;
    civil_parish: string;
    civil_parish_description: string;
    district: string;
    district_description: string;
    door_no: string;
    floor: string;
    gen_address_num: string;
    is_national: boolean;
    locality: string;
    municipality: string;
    municipality_description: string;
    place: string;
    postal_locality: string;
    raw_data: string;
    side: string;
    street_name: string;
    street_type: string;
    type: string;
    zip3: string;
    zip4: string;
    constructor(abbr_building_type?: string, abbr_street_type?: string, building_type?: string, civil_parish?: string, civil_parish_description?: string, district?: string, district_description?: string, door_no?: string, floor?: string, gen_address_num?: string, is_national?: boolean, locality?: string, municipality?: string, municipality_description?: string, place?: string, postal_locality?: string, raw_data?: string, side?: string, street_name?: string, street_type?: string, type?: string, zip3?: string, zip4?: string);
}
export declare class PtAddressResponse extends DataObjectResponse {
    data: PtAddressData;
    success: boolean;
    constructor(data: PtAddressData, success: boolean);
}

export interface AbstractRemoteLoading {
    atr(sessionId?: string, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    apdu(apdu: APDU, sessionId?: string, callback?: (error: RestException, data: CommandResponse) => void): Promise<CommandResponse>;
    apdu(apdu: APDU[], sessionId?: string, callback?: (error: RestException, data: CommandsResponse) => void): Promise<CommandsResponse>;
    ccid(feature: string, command: string, sessionId?: string, callback?: (error: RestException, data: CommandResponse) => void): Promise<CommandResponse>;
    ccidFeatures(sessionId?: string, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    command(tx: string, sessionId?: string, callback?: (error: RestException, data: CommandResponse) => void): Promise<CommandResponse>;
    command(tx: string[], sessionId?: string, callback?: (error: RestException, data: CommandsResponse) => void): Promise<CommandsResponse>;
    closeSession(sessionId?: string, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    isPresent(sessionId?: string, callback?: (error: RestException, data: BoolDataResponse) => void): Promise<BoolDataResponse>;
    openSession(timeout?: number, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
}
export declare class APDU {
    cla: string;
    ins: string;
    p1: string;
    p2: string;
    data: string;
    le: string;
    constructor(cla: string, ins: string, p1: string, p2: string, data?: string, le?: string);
}
export declare class CommandResponse extends T1CResponse {
    data: Command;
    success: boolean;
    constructor(data: Command, success: boolean);
}
export declare class CommandsResponse extends T1CResponse {
    data: Command[];
    success: boolean;
    constructor(data: Command[], success: boolean);
}
export declare class Command {
    sw: string;
    tx: string;
    rx: string;
    constructor(sw: string, tx: string, rx?: string);
}

export interface AbstractBelfius {
    closeSession(sessionId: string, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    isBelfiusReader(sessionId: string, callback?: (error: RestException, data: BoolDataResponse) => void): Promise<BoolDataResponse>;
    nonce(sessionId: string, callback?: (error: RestException, data: CommandResponse) => void): Promise<CommandResponse>;
    openSession(timeout?: number, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    stx(command: string, sessionId: string, callback?: (error: RestException, data: CommandResponse) => void): Promise<CommandResponse>;
}

export interface AbstractAgent {
    get(username?: string, callback?: (error: RestException, data: AgentResponse) => void): Promise<AgentResponse>;
}
export interface AgentResponse extends T1CResponse {
    data: Agent[];
}
export class Agent {
    hostname: string;
    port: number;
    last_update: string;
    constructor(hostname: string, port: number, last_update: string);
}

export interface AbstractFileExchange {
    download(entity: string, type: string, file: ArrayBuffer, filename: string, relpath?: [string], implicitCreationType?: boolean, notifyOnCompletion?: boolean, callback?: (error: RestException, data: FileListResponse) => void): Promise<DataResponse>;
    upload(entity: string, type: string, filename: string, rel_path?: [string], notifyOnCompletion?: boolean, callback?: (error: RestException, data: FileListResponse) => void): Promise<ArrayBuffer>;
    showModal(title: string, text: string, modal: ModalType, timeoutInSeconds?: number, callback?: (error: RestException, data: FileListResponse) => void): Promise<boolean>;
    listTypes(entity?: string, page?: Page, callback?: (error: RestException, data: TypeListResponse) => void): Promise<TypeListResponse>;
    listType(entity: string, type: string, callback?: (error: RestException, data: TypeResponse) => void): Promise<TypeResponse>;
    listTypeContent(entity: string, type: string, relpath?: [string], page?: Page, callback?: (error: RestException, data: FileListResponse) => void): Promise<FileListResponse>;
    listContent(entity: string, page?: Page, callback?: (error: RestException, data: FileListResponse) => void): Promise<FileListResponse>;
    existsType(entity: string, type: string, callback?: (error: RestException, data: BoolDataResponse) => void): Promise<BoolDataResponse>;
    existsFile(entity: string, type: string, relpath: [string], callback?: (error: RestException, data: BoolDataResponse) => void): Promise<BoolDataResponse>;
    getAccessMode(entity: string, type: string, filename?: string, relpath?: [string], callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    createDir(entity: string, type: string, relpath: [string], recursive?: boolean, callback?: (error: RestException, data: FileResponse) => void): Promise<FileResponse>;
    copyFile(entity: string, fromType: string, toType: string, filename: string, newfilename: string, fromrelpath?: [string], torelpath?: [string], callback?: (error: RestException, data: FileResponse) => void): Promise<FileResponse>;
    moveFile(entity: string, fromType: string, toType: string, filename: string, fromrelpath?: [string], torelpath?: [string], callback?: (error: RestException, data: FileResponse) => void): Promise<FileResponse>;
    renameFile(entity: string, type: string, filename: string, newfilename: string, relpath?: [string], callback?: (error: RestException, data: FileResponse) => void): Promise<FileResponse>;
    getFileInfo(entity: string, type: string, filename: string, relpath?: [string], callback?: (error: RestException, data: FileResponse) => void): Promise<FileResponse>;
    createType(entity: string, type: string, initabspath?: [string], showModal?: boolean, timeoutInSeconds?: number, callback?: (error: RestException, data: TypeResponse) => void): Promise<TypeResponse>;
    createTypeDirs(entity: string, type: string, rel_path: [string], show_modal?: boolean, timeoutInSeconds?: number, callback?: (error: RestException, data: FileListResponse) => void): Promise<FileListResponse>;
    updateType(entity: string, type: string, timeoutInSeconds?: number, callback?: (error: RestException, data: TypeResponse) => void): Promise<TypeResponse>;
    deleteType(entity: string, type: string, callback?: (error: RestException, data: boolean) => void): Promise<boolean>;
    getEnabledContainers(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
}
export declare class ListFilesRequest {
    path: string;
    extensions: string[];
    constructor(path: string, extensions: string[]);
}
export declare class File {
    extension: string;
    name: string;
    path: string;
    size: number;
    type: string;
    entity: string;
    last_modification_time: string;
    is_dir: boolean;
    access_mode: AccessMode;
    constructor(extension: string, name: string, path: string, size: number, type: string, entity: string, last_modification_time: string, is_dir: boolean, access_mode: AccessMode);
}
export declare class FileListResponse extends T1CResponse {
    data: FileList;
    success: boolean;
    constructor(data: FileList, success: boolean);
}
export declare class FileList {
    files: File[];
    total: number;
    constructor(files: File[], total: number);
}
export declare class FileResponse extends T1CResponse {
    data: File;
    success: boolean;
    constructor(data: File, success: boolean);
}
export declare class TypeListResponse extends T1CResponse {
    data: TypeList;
    success: boolean;
    constructor(data: TypeList, success: boolean);
}
export declare class TypeResponse extends T1CResponse {
    data: Type;
    success: boolean;
    constructor(data: Type, success: boolean);
}
export declare class Type {
    appid: string;
    entity: string;
    type: string;
    abs_path: string;
    files: number;
    constructor(appid?: string, entity?: string, type?: string, abs_path?: string, access_mode?: AccessMode, status?: string, files?: number);
}
export declare class TypeList {
    types: Type[];
    total: number;
    constructor(types: Type[], total: number);
}
export declare class Page {
    start: number;
    size: number;
    sort: FileSort;
    constructor(start: number, size: number, sort: FileSort);
}
export declare class FileSort {
    static ASC: string;
    static DESC: string;
}
export declare class AccessMode {
    static READ: string;
    static WRITE: string;
    static EXEC: string;
    static READ_WRITE: string;
    static READ_EXEC: string;
    static WRITE_EXEC: string;
    static READ_WRITE_EXEC: string;
}
export declare enum TypeStatus {
    MAPPED = 0,
    UNMAPPED = 1,
}
export declare enum FileAction {
    UPLOAD = 0,
    DOWNLOAD = 1,
    COPY = 2,
    MOVE = 3,
}
export declare class ModalType {
    static INFO: string;
    static CHOICE: string;
}

export class AdminService implements AbstractAdmin {
    static JWT_ERROR_CODES: string[];
    constructor(url: string, connection: LocalAuthAdminConnection);
    activate(callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    atr(atrList: AtrListRequest, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    getLogfile(name: string, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    getLogfileList(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    getPubKey(callback?: (error: RestException, data: PubKeyResponse) => void): Promise<PubKeyResponse>;
    setPubKey(keys: SetPubKeyRequest, callback?: (error: RestException, data: PubKeyResponse) => void): Promise<PubKeyResponse>;
    updateContainerConfig(containers: ContainerSyncRequest, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    resolveAgent(challenge: string, callback?: (error: RestException, data: ResolvedAgentResponse) => void): Promise<ResolvedAgentResponse>;
}

export interface AbstractPkcs11 {
    certificates(slotId: number, options?: Options, callback?: (error: RestException, data: Pkcs11CertificatesResponse) => void): Promise<Pkcs11CertificatesResponse>;
    info(callback?: (error: RestException, data: Pkcs11InfoResponse) => void): Promise<Pkcs11InfoResponse>;
    signData(data: Pkcs11SignData, callback?: (error: RestException, data: DataResponse) => void): Promise<DataResponse>;
    slots(callback?: (error: RestException, data: Pkcs11SlotsResponse) => void): Promise<Pkcs11SlotsResponse>;
    slotsWithTokenPresent(callback?: (error: RestException, data: Pkcs11SlotsResponse) => void): Promise<Pkcs11SlotsResponse>;
    token(slotId: number, callback?: (error: RestException, data: Pkcs11TokenResponse) => void): Promise<Pkcs11TokenResponse>;
    verifySignedData(data: Pkcs11VerifySignedData, callback?: (error: RestException, data: BoolDataResponse) => void): Promise<BoolDataResponse>;
}
export declare class Pkcs11InfoResponse extends DataObjectResponse {
    data: Pkcs11Info;
    success: boolean;
    constructor(data: Pkcs11Info, success: boolean);
}
export declare class Pkcs11Info {
    cryptoki_version: string;
    manufacturer_id: string;
    flags: string;
    library_description: string;
    library_version: string;
    constructor(cryptoki_version: string, manufacturer_id: string, flags: string, library_description: string, library_version: string);
}
export declare class Pkcs11Slot {
    slot_id: string;
    description: string;
    flags: number;
    hardware_version: string;
    firmware_version: string;
    constructor(slot_id: string, description: string, flags: number, hardware_version: string, firmware_version: string);
}
export declare class Pkcs11SlotsResponse extends DataObjectResponse {
    data: Pkcs11Slot[];
    success: boolean;
    constructor(data: Pkcs11Slot[], success: boolean);
}
export declare class Pkcs11Certificate extends T1CCertificate {
    id: string;
    base64: string;
    parsed: object;
    constructor(id: string, base64: string, parsed?: object);
}
export declare class Pkcs11CertificatesResponse extends CertificatesResponse {
    data: Pkcs11Certificate[];
    success: boolean;
    constructor(data: Pkcs11Certificate[], success: boolean);
}
export declare class Pkcs11SignData extends AuthenticateOrSignData {
    slot_id: number;
    cert_id: string;
    algorithm_reference: string;
    data: string;
    pin: string;
    pace: string;
    constructor(slot_id: number, cert_id: string, algorithm_reference: string, data: string, pin?: string, pace?: string);
}
export declare class Pkcs11VerifySignedData extends Pkcs11SignData {
    slot_id: number;
    cert_id: string;
    algorithm_reference: string;
    data: string;
    signature: string;
    pin: string;
    pace: string;
    constructor(slot_id: number, cert_id: string, algorithm_reference: string, data: string, signature: string, pin?: string, pace?: string);
}
export declare class Pkcs11TokenInfo {
    slot_id: string;
    label: string;
    manufacturer_id: string;
    model: string;
    serial_number: string;
    flags: string;
    max_session_count: number;
    session_count: number;
    max_rw_session_count: number;
    rw_session_count: number;
    max_pin_length: number;
    min_pin_length: number;
    total_public_memory: number;
    free_public_memory: number;
    total_private_memory: number;
    free_private_memory: number;
    hardware_version: string;
    firmware_version: string;
    constructor(slot_id: string, label: string, manufacturer_id: string, model: string, serial_number: string, flags: string, max_session_count: number, session_count: number, max_rw_session_count: number, rw_session_count: number, max_pin_length: number, min_pin_length: number, total_public_memory: number, free_public_memory: number, total_private_memory: number, free_private_memory: number, hardware_version: string, firmware_version: string);
}
export declare class Pkcs11TokenResponse extends DataObjectResponse {
    data: Pkcs11TokenInfo;
    success: boolean;
    constructor(data: Pkcs11TokenInfo, success: boolean);
}
export declare class Pkcs11ModuleConfig {
    linux: string;
    mac: string;
    win: string;
    constructor(linux: string, mac: string, win: string);
}

export class AuthClient implements AbstractAuth {
    constructor(cfg: GCLConfig, connection: RemoteApiKeyConnection);
    getJWT(callback?: (error: RestException, data: DSJWTResponse) => void): Promise<DSJWTResponse>;
    refreshJWT(currentJWT: string, callback?: (error: RestException, data: DSJWTResponse) => void): Promise<DSJWTResponse>;
}

export interface AbstractOCVClient {
    getChallenge(digestAlgorithm: string, callback?: (error: RestException, data: ChallengeResponse) => void): void | Promise<ChallengeResponse>;
    validateChallengeSignedHash(data: ChallengeSignedHashData, callback?: (error: RestException, data: ChallengeSignedHashResponse) => void): void | Promise<ChallengeSignedHashResponse>;
    validateCertificateChain(data: CertificateChainData, callback?: (error: RestException, data: CertificateChainResponse) => void): void | Promise<CertificateChainResponse>;
    validateSignature(data: SignatureValidationData, callback?: (error: RestException, data: SignatureValidationResponse) => void): void | Promise<SignatureValidationResponse>;
    getInfo(callback?: (error: RestException, data: OCVInfoResponse) => void): void | Promise<OCVInfoResponse>;
}
export class ChallengeSignedHashData {
    base64Signature: string;
    base64Certificate: string;
    hash: string;
    digestAlgorithm: string;
    constructor(base64Signature: string, base64Certificate: string, hash: string, digestAlgorithm: string);
}
export class SignatureValidationData {
    rawData: string;
    certificate: string;
    signature: string;
    constructor(rawData: string, certificate: string, signature: string);
}
export class CertificateChainData {
    certificateChain: CertificateAndOrder[];
    constructor(certificateChain: CertificateAndOrder[]);
}
export class CertificateChainResponse {
    crlResponse: {
        crlLocations: string[];
        issuerCertificate: string;
        productionData: string;
        signatureAlgorithm: string;
        status: boolean;
        version: string;
    };
    ocspResponse: {
        ocspLocation: string;
        status: boolean;
    };
    constructor(crlResponse: {
        crlLocations: string[];
        issuerCertificate: string;
        productionData: string;
        signatureAlgorithm: string;
        status: boolean;
        version: string;
    }, ocspResponse: {
        ocspLocation: string;
        status: boolean;
    });
}
export class CertificateAndOrder {
    certificate: string;
    order: number;
    constructor(certificate: string, order: number);
}
export class ChallengeResponse {
    hash: string;
    digestAlgorithm: string;
    constructor(hash: string, digestAlgorithm: string);
}
export class ChallengeSignedHashResponse extends ChallengeResponse {
    result: boolean;
    hash: string;
    digestAlgorithm: string;
    constructor(result: boolean, hash: string, digestAlgorithm: string);
}
export class SignatureValidationResponse {
    rawData: string;
    signature: string;
    digest: string;
    signatureAlgorithm: string;
    constructor(rawData: string, signature: string, digest: string, signatureAlgorithm: string, result: string);
}
export class OCVInfoResponse {
    configFile: string;
    build: string;
    version: string;
    environemnt: string;
    constructor(configFile: string, build: string, version: string, environemnt: string);
}

class GCLConfig {
    constructor(options?: any);
    readonly authUrl: string;
    readonly ocvUrl: string;
    ocvContextPath: string;
    gclUrl: string;
    readonly dsUrl: string;
    dsContextPath: string;
    dsFileContextPath: string;
    apiKey: string;
    citrix: boolean;
    isManaged: boolean;
    agentPort: number;
    implicitDownload: boolean;
    readonly dsFileDownloadUrl: string;
    gwUrl: string;
    localTestMode: boolean;
    forceHardwarePinpad: boolean;
    defaultSessionTimeout: number;
    tokenCompatible: boolean;
    v2Compatible: boolean;
    defaultConsentDuration: number;
    defaultConsentTimeout: number;
    syncManaged: boolean;
    pkcs11Config: Pkcs11ModuleConfig;
    osPinDialog: boolean;
    containerDownloadTimeout: number;
    readonly gwJwt: Promise<string>;
    contextToken: string;
    gclJwt: string;
    getGwJwt(): Promise<string>;
}
export { GCLConfig };

export interface Connection {
    get(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    post(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    put(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    delete(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
}
export interface RequestBody {
    [key: string]: any;
}
export interface QueryParams {
    [key: string]: any;
}
export interface RequestHeaders {
    [key: string]: string;
}
export interface RequestCallback {
    (error: any, data: any): void;
}
export interface SecurityConfig {
    sendGwJwt: boolean;
    sendGclJwt: boolean;
    sendApiKey: boolean;
    sendToken: boolean;
    skipCitrixCheck: boolean;
}
export abstract class GenericConnection implements Connection {
    cfg: GCLConfig;
    static readonly AUTH_TOKEN_HEADER: string;
    static readonly BROWSER_AUTH_TOKEN: string;
    static readonly RELAY_STATE_HEADER_PREFIX: string;
    constructor(cfg: GCLConfig);
    get(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    post(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    put(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    delete(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    getRequestHeaders(headers: RequestHeaders): RequestHeaders;
    getSecurityConfig(): SecurityConfig;
    protected handleRequest(basePath: string, suffix: string, method: string, gclConfig: GCLConfig, securityConfig: SecurityConfig, body?: RequestBody, params?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
}
export class LocalAuthAdminConnection extends GenericConnection implements Connection {
    cfg: GCLConfig;
    constructor(cfg: GCLConfig);
    getSecurityConfig(): SecurityConfig;
    requestLogFile(basePath: string, suffix: string, callback?: RequestCallback): Promise<any>;
}
export class LocalAuthConnection extends GenericConnection implements Connection {
    cfg: GCLConfig;
    constructor(cfg: GCLConfig);
    getSecurityConfig(): SecurityConfig;
    getSkipCitrix(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    postSkipCitrix(basePath: string, suffix: string, queryParams?: QueryParams, body?: RequestBody, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    requestLogFile(basePath: string, suffix: string, callback?: RequestCallback): Promise<any>;
}
export class LocalConnection extends GenericConnection implements Connection {
    cfg: GCLConfig;
    constructor(cfg: GCLConfig);
    getRequestHeaders(headers: RequestHeaders): RequestHeaders;
    getSecurityConfig(): SecurityConfig;
    getSkipCitrix(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    requestFile(basePath: string, suffix: string, body: {
        entity: string;
        type: string;
        filename: string;
        rel_path: string[];
        notify_on_completion: boolean;
    }, callback?: RequestCallback): Promise<any>;
    postFile(basePath: string, suffix: string, body: RequestBody, queryParams: QueryParams, callback?: RequestCallback): Promise<any>;
}
export class RemoteApiKeyConnection extends GenericConnection implements Connection {
    cfg: GCLConfig;
    constructor(cfg: GCLConfig);
    getSecurityConfig(): SecurityConfig;
}
export class RemoteJwtConnection extends GenericConnection implements Connection {
    cfg: GCLConfig;
    constructor(cfg: GCLConfig);
    getSecurityConfig(): SecurityConfig;
}
export class LocalTestConnection extends GenericConnection implements Connection {
    config: any;
    get(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    post(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    put(basePath: string, suffix: string, body: RequestBody, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    delete(basePath: string, suffix: string, queryParams?: QueryParams, headers?: RequestHeaders, callback?: RequestCallback): Promise<any>;
    getRequestHeaders(headers: RequestHeaders): RequestHeaders;
}

export declare class Options {
    parseCerts: boolean;
    filters: string[];
    constructor(parseCerts: boolean, filters?: string[]);
}
export declare class RequestOptions {
    parseCerts: boolean;
    params: {
        [key: string]: string;
    };
    callback: () => void;
    constructor(parseCerts: boolean, params?: {
        [key: string]: string;
    }, callback?: () => void);
}
export declare class RequestHandler {
    static determineOptions(firstParam: any, secondParam: any): RequestOptions;
    static determineOptionsWithFilter(firstParam: string[] | Options): RequestOptions;
}

export interface AbstractDataContainer {
    create(data: any, callback?: (error: RestException, data: any) => void): Promise<any>;
    read(id?: string, callback?: (error: RestException, data: any) => void): Promise<any>;
    update(id: string, data: any, callback?: (error: RestException, data: any) => void): Promise<any>;
    delete(id: string, callback?: (error: RestException, data: any) => void): Promise<any>;
}

export interface AbstractAdmin {
    activate(callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    atr(atrList: AtrListRequest, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    getLogfile(name: string, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    getLogfileList(callback?: (error: RestException, data: DataArrayResponse) => void): Promise<DataArrayResponse>;
    getPubKey(callback?: (error: RestException, data: PubKeyResponse) => void): Promise<PubKeyResponse>;
    setPubKey(keys: SetPubKeyRequest, callback?: (error: RestException, data: PubKeyResponse) => void): Promise<PubKeyResponse>;
    updateContainerConfig(containers: ContainerSyncRequest, callback?: (error: RestException, data: T1CResponse) => void): Promise<T1CResponse>;
    resolveAgent(challenge: string, callback?: (error: RestException, data: ResolvedAgentResponse) => void): Promise<ResolvedAgentResponse>;
}
export class AtrListRequest {
    hash: string;
    storagePath: string;
    constructor(hash: string, storagePath: string);
}
export class SetPubKeyRequest {
    encryptedPublicKey: string;
    encryptedAesKey: string;
    constructor(encryptedPublicKey: string, encryptedAesKey: string);
}
export class PubKeyResponse implements T1CResponse {
    data: PubKeys;
    success: boolean;
    constructor(data: PubKeys, success: boolean);
}
export class PubKeys {
    device: string;
    ssl: string;
    ds: string;
    constructor(device: string, ssl: string, ds?: string);
}
export class ContainerSyncRequest {
    containerResponses: DSContainer[];
    constructor(containerResponses: DSContainer[]);
}
export class ResolvedAgent {
    hostname: string;
    challenge: string;
    last_update: string;
    metadata: any;
    port: number;
    type: string;
    username: string;
    constructor(hostname?: string, challenge?: string, last_update?: string, metadata?: any, port?: number, type?: string, username?: string);
}
export interface ResolvedAgentResponse extends T1CResponse {
    data: ResolvedAgent[];
}

export interface AbstractAuth {
    getJWT(callback?: (error: RestException, data: JWTResponse) => void): Promise<JWTResponse>;
    refreshJWT(currentJWT: string, callback?: (error: RestException, data: JWTResponse) => void): Promise<JWTResponse>;
}
export class JWTResponse {
    token: string;
    constructor(token: string);
}

